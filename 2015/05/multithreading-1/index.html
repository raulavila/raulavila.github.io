<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Multithreading para dummies (1)
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Raúl Ávila" href="/atom.xml">

</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h1 class="masthead-title">
          <a href="/" title="Home">Raúl Ávila</a>
        </h1>

            <small><a href="/sobre-mi">Sobre mí</a></small>
            &nbsp;&nbsp;&nbsp;
            <small><a href="/archivos">Archivos</a></small>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">Multithreading para dummies (1)</h1>
  <time datetime="2015-05-31T00:00:00+01:00" class="post-date">31/05/2015</time>
  <div class="post-tags">
    
    | <a href="/tag/Java">Java</a> |
    
    | <a href="/tag/desarrollo">desarrollo</a> |
    
    | <a href="/tag/multithreading">multithreading</a> |
    
  </div>
  <div class="post-share">
    <a class="twitter-share-button"
    data-via="_Raul_Avila"
    data-count="none"
    href="https://twitter.com/share">Tweet</a>
  </div>
  <p>Voy a iniciar con este post una serie en la que introduciré conceptos básicos de programación concurrente / multithreading. Lo sé, Internet está plagado de referencias, tutoriales, artículos, etc, pero mi intención será dar un enfoque diferente en este blog. Lo normal, o al menos eso me ha parecido a mí siempre que he intentado empaparme de este tema es profundizar mucho en la teoría por un lado, o bien en ejemplos excesivamente complejos por otro.</p>

<p>Por mi parte lo que intentaré es no soltar demasiadas parrafadas en mis posts, y llevar a cabo un acercamiento práctico de los diferentes conceptos y API’s que es necesario conocer para desarrollar aplicaciones concurrentes en Java. Además, trataré de hacerlo mediante el desarrollo de una aplicación extremadamente sencilla que irá creciendo en complejidad añadiendo un concepto nuevo cada vez. Espero conseguir mi objetivo.</p>

<!--break-->

<h2 id="la-aplicacin-ping-pong">La aplicación: Ping pong</h2>

<p>Tan sencillo como eso. Nuestra aplicación Java deberá mostrar por salida estándar y de forma alterna los textos “ping” / “pong”, además de un texto cabecera y de finalización:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Game starting...!
ping
pong
ping
pong
//....
Game finished!</code></pre></figure>

<p>Conceptualmente deberán existir dos jugadores / actores, que deberán imprimir el texto “ping” y “pong”. El actor “ping” deberá jugar primero.</p>

<h3 id="versin-cero-un-solo-hilo">Versión cero: un solo hilo</h3>

<p>La primera versión correrá en un solo hilo de ejecución, por lo que no habrá programación concurrente que valga :). En estas primeras versiones, además, el juego finalizará después de que ambos jugadores hayan participado un número de veces (definido por constante), pongamos 10.</p>

<p>Veamos como quedaría el código de la clase <code class="highlighter-rouge">Player</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Player</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">text</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">turns</span> <span class="o">=</span> <span class="n">Game</span><span class="o">.</span><span class="na">MAX_TURNS</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">Player</span> <span class="n">nextPlayer</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Player</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">play</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">gameFinished</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
            <span class="n">turns</span><span class="o">--;</span>
            <span class="n">nextPlayer</span><span class="o">.</span><span class="na">play</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">gameFinished</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">turns</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setNextPlayer</span><span class="o">(</span><span class="n">Player</span> <span class="n">nextPlayer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nextPlayer</span> <span class="o">=</span> <span class="n">nextPlayer</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>Cada jugador imprime su texto y le dice al otro que juegue, por lo que se van alternando. La clase que inicia el juego sería bastante sencilla también:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Game</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_TURNS</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">Player</span> <span class="n">player1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Player</span><span class="o">(</span><span class="s">"ping"</span><span class="o">);</span>
        <span class="n">Player</span> <span class="n">player2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Player</span><span class="o">(</span><span class="s">"pong"</span><span class="o">);</span>

        <span class="n">player1</span><span class="o">.</span><span class="na">setNextPlayer</span><span class="o">(</span><span class="n">player2</span><span class="o">);</span>
        <span class="n">player2</span><span class="o">.</span><span class="na">setNextPlayer</span><span class="o">(</span><span class="n">player1</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Game starting...!"</span><span class="o">);</span>

        <span class="n">player1</span><span class="o">.</span><span class="na">play</span><span class="o">();</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Game finished!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Poca historia. Vemos que en el constructor de <code class="highlighter-rouge">Player</code> no es posible pasar quien es el otro jugador porque no siempre va a estar instanciado, por lo que hay que hacerlo mediante setter.</p>

<p>También vemos como en <code class="highlighter-rouge">Player</code> el atributo <code class="highlighter-rouge">text</code> es declarado <code class="highlighter-rouge">final</code>. Es buena práctica en aplicaciones concurrentes (y en todas, la verdad) declarar un atributo como <code class="highlighter-rouge">final</code> si sabemos que no va a ser modificado. No sólo hace más fiable a nuestro código, también garantiza la visibilidad de las variables entre threads, un concepto conocido como “Safe publication”, y del que podéis leer una discusión <a href="http://stackoverflow.com/questions/801993/java-multi-threading-safe-publication">aquí</a>. Yendo un poco más allá, siempre que podamos deberíamos diseñar nuestras clases como <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html">inmutables</a>, aunque en nuestro ejemplo no es posible.</p>

<h3 id="versin-1-jugadores-como-threads">Versión 1: jugadores como threads</h3>

<p>Vamos a llevar nuestra aplicación un poco más allá para que funcione en modo concurrente. Cómo la intención es hacerlo en incrementos pequeños nos iremos encontrando que nuestros primeros acercamientos no funcionan como es debido.</p>

<p>En primer lugar crearemos nuestra clase <code class="highlighter-rouge">Player</code> como <code class="highlighter-rouge">Runnable</code> (más información <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html">aquí</a>):</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Player</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">text</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">turns</span> <span class="o">=</span> <span class="n">Game</span><span class="o">.</span><span class="na">MAX_TURNS</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">Player</span> <span class="n">nextPlayer</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">mustPlay</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Player</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">gameFinished</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">mustPlay</span><span class="o">);</span>

            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
            <span class="n">turns</span><span class="o">--;</span>

            <span class="k">this</span><span class="o">.</span><span class="na">mustPlay</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">nextPlayer</span><span class="o">.</span><span class="na">mustPlay</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">gameFinished</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">turns</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setNextPlayer</span><span class="o">(</span><span class="n">Player</span> <span class="n">nextPlayer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nextPlayer</span> <span class="o">=</span> <span class="n">nextPlayer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setMustPlay</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">mustPlay</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mustPlay</span> <span class="o">=</span> <span class="n">mustPlay</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>El método principal (<code class="highlighter-rouge">run</code>) estará formado por un bucle que itera hasta que termina el número de turnos para el jugador. Además, en cada iteración del bucle se produce una <a href="http://es.wikipedia.org/wiki/Espera_activa">espera activa</a> hasta que le llegue el turno. Una vez le toca imprime el texto, se indica a sí mismo que no le toca jugar hasta que alguien indique lo contrario, y le dice al siguiente jugador que es su turno.</p>

<p>Una gran diferencia entre esta clase <code class="highlighter-rouge">Player</code> y la anterior es que en la primera versión un jugador le indicaba al otro que jugara mediante paso de mensajes (invocando al método <code class="highlighter-rouge">play</code>), mientras que aquí se realiza modificando el valor de un flag (<code class="highlighter-rouge">mustPlay</code>), que cada jugador de forma individual es responsable de verificar.</p>

<p>Veamos cómo quedaría la clase <code class="highlighter-rouge">Game</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Game</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_TURNS</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">Player</span> <span class="n">player1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Player</span><span class="o">(</span><span class="s">"ping"</span><span class="o">);</span>
        <span class="n">Player</span> <span class="n">player2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Player</span><span class="o">(</span><span class="s">"pong"</span><span class="o">);</span>

        <span class="n">player1</span><span class="o">.</span><span class="na">setNextPlayer</span><span class="o">(</span><span class="n">player2</span><span class="o">);</span>
        <span class="n">player2</span><span class="o">.</span><span class="na">setNextPlayer</span><span class="o">(</span><span class="n">player1</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Game starting...!"</span><span class="o">);</span>

        <span class="n">player1</span><span class="o">.</span><span class="na">setMustPlay</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">player2</span><span class="o">);</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">player1</span><span class="o">);</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Game finished!"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>La gran diferencia es que los threads se inician de forma separada, y nosotros solo somos responsables de configurar el flag <code class="highlighter-rouge">mustPlay</code> de forma adecuada. De hecho, he arrancado primero el thread de <code class="highlighter-rouge">player2</code> a propósito para confirmar que incluso así se imprime primero el mensaje “ping”.</p>

<p>Veamos qué pasa al iniciar la aplicación:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Game starting...!
ping
Game finished!</code></pre></figure>

<p>¿Qué ha ocurrido? Nuestra aplicación tiene ahora tres hilos:</p>

<ul>
  <li>Hilo principal (<code class="highlighter-rouge">Game.main</code>)</li>
  <li>Hilo player1</li>
  <li>Hilo player2</li>
</ul>

<p>El problema es que el hilo principal finaliza tan pronto como inicia los threads, por lo que aunque los otros dos hilos continúan su ejecución y finalizan correctamente nuestro IDE no recoge la salida de esos threads adicionales, creando además doble confusión al imprimir el mensaje “Game finished!”. Para evitar esto una forma bastante directa es utilizar el método <code class="highlighter-rouge">join()</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Game</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_TURNS</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">Player</span> <span class="n">player1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Player</span><span class="o">(</span><span class="s">"ping"</span><span class="o">);</span>
        <span class="n">Player</span> <span class="n">player2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Player</span><span class="o">(</span><span class="s">"pong"</span><span class="o">);</span>

        <span class="n">player1</span><span class="o">.</span><span class="na">setNextPlayer</span><span class="o">(</span><span class="n">player2</span><span class="o">);</span>
        <span class="n">player2</span><span class="o">.</span><span class="na">setNextPlayer</span><span class="o">(</span><span class="n">player1</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Game starting...!"</span><span class="o">);</span>

        <span class="n">player1</span><span class="o">.</span><span class="na">setMustPlay</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">player2</span><span class="o">);</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">player1</span><span class="o">);</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Game finished!"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>Este método condiciona el progreso del hilo en ejecución a la finalización del hilo sobre el que se invoca el método <code class="highlighter-rouge">join</code>. Al ser join un método bloqueante es susceptible de ser interrumpido, por lo que lanza la checked exception <code class="highlighter-rouge">InterruptedException</code>. Más adelante hablaremos de las complicaciones que existen para interrumpir un thread.</p>

<p>Por tanto, ahora nuestro thread principal esperará hasta que los jugadores agoten sus turnos…o no? Bien, si ejecutamos la aplicación un par de veces, dependiendo de la suerte que tengamos es posible que todo sea correcto, pero si lanzamos ejecuciones reiteradas es más que posible que obtengamos una salida como la que sigue:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Game starting...!
ping</code></pre></figure>

<p>¡Nuestra aplicación se queda bloqueada y no progresa en absoluto!</p>

<p>¿Qué ha pasado? Uno de los grandes problemas en la programación concurrente es la “visibilidad”. Java solo garantiza la visiblidad de atributos compartidos entre threads si seguimos una serie de directrices, que vienen reguladas por el <a href="http://en.wikipedia.org/wiki/Java_memory_model">Java Memory Model</a>, y en concreto por la relación “happens-before”. Según la Wikipedia, en Java esta relación viene a decir que:</p>

<blockquote>
  <p>In Java specifically, a happens-before relationship is a guarantee that memory written to by statement A is visible to statement B, that is, that statement A completes its write before statement B starts its read</p>
</blockquote>

<p>En nuestro código no estamos siguiendo ninguna convención que nos asegure la visibilidad de la modificación del atributo <code class="highlighter-rouge">mustPlay</code> entre threads. Evidentemente, la modificación de su propio <code class="highlighter-rouge">mustPlay</code> es visible para el propio thread, que no continúa jugando, pero de la forma en que lo estamos haciendo la modificación del atributo <code class="highlighter-rouge">mustPlay</code> del otro thread no se hace visible para el thread interesado, y nuestro programa queda en situación de bloqueo (o <a href="http://en.wikipedia.org/wiki/Deadlock">deadlock</a>).</p>

<p>Para corregir este problema vamos a introducir el modificador <code class="highlighter-rouge">volatile</code>. <a href="http://www.javamex.com/tutorials/synchronization_volatile.shtml">Este modificador</a> indica a la JVM que el atributo es susceptible de ser compartido entre threads, y que por tanto sus lecturas no deben ser cacheadas en modo alguno, accediendo siempre a memoria principal, y además sus escrituras deben hacerse de forma atómica y hacerse visibles de manera inmediata.</p>

<p>Nuestro código quedaría así:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Player</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
    <span class="c1">//...</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">mustPlay</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="c1">//....</span>
<span class="o">}</span></code></pre></figure>

<p>Y ahora sí, nuestra aplicación funciona de forma determinista en cada ejecución. Uno de los mayores problemas de la visibilidad en aplicaciones concurrentes es que falla aleatoriamente, por lo que si no somos conscientes de las directrices a seguir, depurar estos problemas puede ser extremadamente complicado.</p>

<h3 id="versin-2-juego-infinito">Versión 2: juego infinito</h3>

<p>En lugar de jugar un número determinado de turnos vamos a poner a los dos actores a jugar para siempre. O mejor dicho, hasta que el hilo principal quiera. Para ello, debemos utilizar las funcionalidades que ofrece Java para interrumpir un thread. Veamos cómo quedaría la clase <code class="highlighter-rouge">Game</code>:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Game</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">Player</span> <span class="n">player1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Player</span><span class="o">(</span><span class="s">"ping"</span><span class="o">);</span>
        <span class="n">Player</span> <span class="n">player2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Player</span><span class="o">(</span><span class="s">"pong"</span><span class="o">);</span>

        <span class="n">player1</span><span class="o">.</span><span class="na">setNextPlayer</span><span class="o">(</span><span class="n">player2</span><span class="o">);</span>
        <span class="n">player2</span><span class="o">.</span><span class="na">setNextPlayer</span><span class="o">(</span><span class="n">player1</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Game starting...!"</span><span class="o">);</span>

        <span class="n">player1</span><span class="o">.</span><span class="na">setMustPlay</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

        <span class="n">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">player2</span><span class="o">);</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">player1</span><span class="o">);</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="c1">//Let the players play!</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">//Tell the players to stop</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>

        <span class="c1">//Wait until players finish</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Game finished!"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>Vemos que, una vez iniciados los jugadores, la clase principal se duerme durante un tiempo (2ms), y a nada que regresa a su estado “running” <strong>les pide</strong> a los dos threads que finalicen.</p>

<p>Repito, <strong>les pide</strong>. Lo único que ocurre al invocar el método <code class="highlighter-rouge">interrupt</code> sobre un thread es que se pone a true un flag “interrupted” en ese thread. Es responsabilidad del propio thread actuar si lo desea, realizar labores de limpieza y finalizar. Pero bien puede decidir no hacer nada de nada y continuar con su ejecución (aunque eso no sería muy correcto, claro). La forma de consultar ese flag es mediante el método <code class="highlighter-rouge">Thread.interrupted()</code>, por lo que nuestra clase <code class="highlighter-rouge">Player</code> quedarían así:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Player</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">text</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">Player</span> <span class="n">nextPlayer</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">mustPlay</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Player</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">mustPlay</span><span class="o">);</span>

            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>

            <span class="k">this</span><span class="o">.</span><span class="na">mustPlay</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">nextPlayer</span><span class="o">.</span><span class="na">mustPlay</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setNextPlayer</span><span class="o">(</span><span class="n">Player</span> <span class="n">nextPlayer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nextPlayer</span> <span class="o">=</span> <span class="n">nextPlayer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">setMustPlay</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">mustPlay</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mustPlay</span> <span class="o">=</span> <span class="n">mustPlay</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>En lugar de chequear en cada vuelta del bucle si hemos agotado turnos miramos el estado del flag “interrupted”, y concluimos en caso de que sea true. Tan sencillo como eso.</p>

<h4 id="versin-2b-ms-sobre-interrupt">Versión 2b: Más sobre interrupt</h4>

<p>Antes de finalizar este primer post de la serie, vamos a mirar un poco más en profundidad las implicaciones de interrumpir un thread.</p>

<p>En varias ocasiones hemos visto como algunos de los métodos de la clase <code class="highlighter-rouge">Thread</code> (<code class="highlighter-rouge">join</code>, <code class="highlighter-rouge">sleep</code>…) lanzan la excepción <code class="highlighter-rouge">InterruptedException</code>. Esto ocurre cuando un thread es interrumpido encontrándose en situación de bloqueo debido a la invocación de alguno de estos métodos. En tal caso, lo que ocurre es que el método limpia el flag “interrupted” en el thread en cuestión, y lanza la excepción <code class="highlighter-rouge">InterruptedException</code>. Sin ser yo muy fan de las checked exceptions, este es uno de los casos en los que encuentro más justificado su uso.</p>

<p>Modifiquemos ligeramente la clase <code class="highlighter-rouge">Player</code> para que, una vez le llegue el turno a un jugador se duerma durante 1ms antes de imprimir el texto:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Player</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
    <span class="c1">//...</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">mustPlay</span><span class="o">);</span>

            <span class="k">try</span> <span class="o">{</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>

            <span class="k">this</span><span class="o">.</span><span class="na">mustPlay</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="n">nextPlayer</span><span class="o">.</span><span class="na">mustPlay</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//...</span>
<span class="o">}</span></code></pre></figure>

<p>Utilizando la misma versión de la clase <code class="highlighter-rouge">Game</code>, es altamente probable que el juego se ejecute indefenidamente. ¿Por qué? Porque si la interrupción le llega al thread mientras está durmiendo, el método sleep se traga el estado “interrupted” antes de lanzar la excepción, y como nosotros sólo nos hemos limitado a imprimir el error, el bucle no detecta este estado interrupted y continúa para siempre.</p>

<p>La solución a esto es restablecer el Thread a interrupted:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span><span class="o">(!</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">mustPlay</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>

        <span class="k">this</span><span class="o">.</span><span class="na">mustPlay</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">nextPlayer</span><span class="o">.</span><span class="na">mustPlay</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>En general, hemos de ser muy cuidadosos a la hora de manejar <code class="highlighter-rouge">InterruptedException</code>. Otra estrategia recomendada, que implicaría modificar la lógica de nuestro método <code class="highlighter-rouge">run</code>, es volver a lanzar la excepción para que sea manejada en algún otro lugar. En ningún caso <strong>nunca</strong> debemos tragarnos la excepción sin más.</p>

<p>Quedan muchas mejoras por llevar a cabo, la aplicación está lejos de ser óptima (empezando por esa horrenda espera activa). <a href="/2015/06/multithreading-2">En el siguiente post</a> añadiremos mejoras para optimizar el uso de la CPU mediante el uso de locks y condiciones.</p>

<p>(El código, como siempre, <a href="https://github.com/raulavila/blog-examples/tree/master/src/main/java/com/raulavila/pingpong">en Github</a>).</p>

</article>

<aside class="related">
  <h2>Posts relacionados</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2016/03/hello-world-tdd/">
            TDD&#58; Hello World Web App
            <small><time datetime="2016-03-12T00:00:00+00:00">12/03/2016</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2016/03/spock-vs-junit/">
            Spock vs JUnit
            <small><time datetime="2016-03-05T00:00:00+00:00">05/03/2016</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2016/02/codigo-autogenerado/">
            Revisa tu código autogenerado
            <small><time datetime="2016-02-20T00:00:00+00:00">20/02/2016</time></small>
          </a>
        </h3>
      </li>
    
  </ul>
</aside>

        
<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'raulavila'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2016">2016</time> Raúl Ávila. Blog creado con <a href="http://jekyllrb.com">Jekyll</a>.
          Plantilla basada en <a href="http://getpoole.com">Poole</a>.
          <a href="/atom.xml">Atom Feed</a></a>.
          <br>
        </small>
      </footer>
    </div>

  <script>
window.twttr=(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return;js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);t._e=[];t.ready=function(f){t._e.push(f);};return t;}(document,"script","twitter-wjs"));
</script>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58942569-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>

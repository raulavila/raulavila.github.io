<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Raúl Ávila</title>
 <link href="http://www.raulavila.com/atom.xml" rel="self"/>
 <link href="http://www.raulavila.com/"/>
 <updated>2017-05-02T18:46:35+01:00</updated>
 <id>http://www.raulavila.com/</id>
 <author>
   <name>Raul Avila</name>
   <email/>
 </author>

 
 <entry>
   <title>Cómo funciona Git (y 4)</title>
   <link href="http://www.raulavila.com/2017/04/como-funciona-git-4/"/>
   <updated>2017-04-30T00:00:00+01:00</updated>
   <id>http://www.raulavila.com/2017/04/como-funciona-git-4</id>
   <content type="html">&lt;p&gt;Tenía pendiente escribir la última parte de esta serie desde hace tiempo. Tras revisar &lt;a href=&quot;/2017/03/como-funciona-git-3/&quot;&gt;cómo Git gestiona merge y rebase&lt;/a&gt;, queda por ver la forma en que Git gestiona la capa de distribución, es decir, el trabajo y sincronización con repositorios remotos.&lt;/p&gt;

&lt;p&gt;Como ya sabemos, Git es un sistema de control distribuido de versiones, donde cada persona no tiene más que una copia completa del repositorio. Es decir, cada usuario que clone un repositorio Git tendrá una copia de la carpeta &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;, carpeta que contiene montones de cosas, según vimos en anteriores posts de la serie.&lt;/p&gt;

&lt;!--break--&gt;

&lt;p&gt;Normalmente el repositorio que sirve de referencia para todos los usuarios estará alojado en algún sistema como &lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;, &lt;a href=&quot;https://bitbucket.org/&quot;&gt;BitBucket&lt;/a&gt; o &lt;a href=&quot;https://about.gitlab.com/&quot;&gt;GitLab&lt;/a&gt;, de forma que cuando queremos empezar a trabajar con un proyecto haremos un &lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt; de ese repositorio “remoto”. Será con esta versión “de referencia” con la que nosotros sincronizaremos nuestros cambios.&lt;/p&gt;

&lt;p&gt;Internamente, Git almacena cierta información relacionada con este repositorio remoto en el fichero &lt;code class=&quot;highlighter-rouge&quot;&gt;.git/config&lt;/code&gt;. Veamos, por ejemplo, lo que este fichero contiene para el caso del repositorio donde alojo el código de este blog:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
	precomposeunicode = true
[remote &quot;origin&quot;]
	url = https://github.com/raulavila/blog-source-code.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch &quot;master&quot;]
	remote = origin
	merge = refs/heads/master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Las dos secciones importantes son las últimas, el &lt;code class=&quot;highlighter-rouge&quot;&gt;core&lt;/code&gt; existirá incluso tras crear un repositorio Git local sin llegar a sincronizarlo con un remoto. Como véis, define ciertas características de donde está alojado &lt;code class=&quot;highlighter-rouge&quot;&gt;origin&lt;/code&gt;, que es el nombre por defecto que Git asocia al repositorio remoto principal (ahora volvemos a esto). También vemos información que mapea nuestra rama &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; con el repositorio remoto &lt;code class=&quot;highlighter-rouge&quot;&gt;origin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Git permite asociar varios repositorios remotos a un repositorio local, &lt;a href=&quot;https://help.github.com/articles/adding-a-remote/&quot;&gt;tal y como está descrito aquí&lt;/a&gt;, aunque no es algo que recomiende especialmente. Cada uno de los remotos deberá tener un alias designado, siendo &lt;code class=&quot;highlighter-rouge&quot;&gt;origin&lt;/code&gt; el primer alias por defecto que utiliza Git.&lt;/p&gt;

&lt;p&gt;Sigamos. Recordemos que los objetos de Git en general, y los commits en particular, son inmutables. Y lo son tanto en local como en remoto, por tanto (y me estoy repitiendo), clonar un repositorio se trae a local una copia de todos estos commits. Lo que no es inmutable en absoluto es una rama (un puntero a un commmit, a fin de cuentas), y aquí es donde entra en juego la capa de distribución de Git.&lt;/p&gt;

&lt;p&gt;En efecto, lo que ocurre en nuestro repositorio local es que Git crea dos copias de la rama en cuestion, una versión local y una remota. Supongamos que estamos trabajando con &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;, tras hacer Git clone de un repositorio con una historia en dicha rama, lo que tenemos es:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-remotes-1.jpg&quot; alt=&quot;Git Remotes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Es decir, existe una rama llamada &lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt;, apuntando al último commit del repositorio remoto, que en este caso es el mismo que tenemos en local. La información de esta rama &lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt; está contenida en el fichero &lt;code class=&quot;highlighter-rouge&quot;&gt;.git/refs/remotes/origin/master&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ cat .git/refs/remotes/origin/master
aa90e471ababde242281c833fffea255f69dd28a

$ git show-ref master
aa90e471ababde242281c833fffea255f69dd28a refs/heads/master
aa90e471ababde242281c833fffea255f69dd28a refs/remotes/origin/master

$ cat .git/HEAD
ref: refs/heads/master

$ cat .git/refs/heads/master
aa90e471ababde242281c833fffea255f69dd28a&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;El comando &lt;code class=&quot;highlighter-rouge&quot;&gt;show-ref &amp;lt;rama&amp;gt;&lt;/code&gt; nos muestra información del commit al que apunta la rama en cuestión tanto en local como en remoto. El resto de comandos del ejemplo creo que deberían estar claros a estas alturas si habéis seguido esta serie.&lt;/p&gt;

&lt;h2 id=&quot;sincronizando-con-el-repositorio-remoto&quot;&gt;Sincronizando con el repositorio remoto&lt;/h2&gt;

&lt;p&gt;Los “problemillas” en Git suelen surgir de vez en cuando a la hora de sincronizar nuestro repositorio local con el remoto. Durante el resto del post vamos a revisar diferentes escenarios.&lt;/p&gt;

&lt;h3 id=&quot;escenario-1&quot;&gt;Escenario 1&lt;/h3&gt;

&lt;p&gt;Ocurre cuando somos los únicos trabajando en &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-remotes-2.jpg&quot; alt=&quot;Git remotes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Vemos en la imagen como hemos añadido un nuevo commit (2), que ha hecho moverse los punteros &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;, pero no el puntero &lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt;. Esto es así porque en el repositorio remoto, la rama &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; sigue exactamente igual. En este escenario, sincronizar ambos repositorios es tan sencillo como hacer &lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt;, y nuestro repositorio quedará así:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-remotes-3.jpg&quot; alt=&quot;Git remotes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Si cualquier otro usuario trabajando con este repositorio, pero sin haber hecho ningún commit adicional en &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;, hiciera &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;, Git resolvería la situación fácilmente, desembocando en el mismo diagrama. Los problemillas empiezan a surgir cuando ese segundo usuario sí ha hecho algún que otro commit.&lt;/p&gt;

&lt;h3 id=&quot;escenario-2&quot;&gt;Escenario 2&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-remotes-4.jpg&quot; alt=&quot;Git remotes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Espero que el diagrama esté más o menos claro. En este escenario, un segundo usuario ha hecho un commit (3) en su rama &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; local, y la rama &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; remota ya contiene el commit (2) que el usuario anterior incluyó en su push. Pero, para ese segundo usuario (el que tiene el commit (3)), su puntero &lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt; no ha cambiado, ya que no hemos sincronizado, de forma que si intentamos hacer &lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt;, Git detectará que la rama &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; remota no está sincronizada con nuestra rama &lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt; local, y nos dará un conflicto / error:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git push
To github.com:raulavila/dummy.git
 ! [rejected]        master -&amp;gt; master (fetch first)
error: failed to push some refs to 'git@github.com:raulavila/dummy.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ante esta situación podemos optar por la solución bestia, que es invocar el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;git push -f&lt;/code&gt; (force push). Con esto estaremos indicando a Git que nuestra rama &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; es la buena, y que sobrescriba toda la historia de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; en &lt;code class=&quot;highlighter-rouge&quot;&gt;origin&lt;/code&gt; para que coincida con la copia en local. Como os podéis imaginar, esto es muy, muy peligroso. Personalmente, la única situación en la que he encontrado una buena justificación para hacerlo es cuando yo soy la única persona trabajando en una rama diferente de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;, pero en la que llevo a cabo rebases de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; con frecuencia. Al hacer rebase reescribo la historia de mi rama, y si hago push a la remota, habrá divergencias todo el tiempo. Pero al ser yo la única persona que trabaja en esa rama, sé con seguridad que no hay problema en forzar un push.&lt;/p&gt;

&lt;p&gt;Una estrategia más segura, es hacerlo en dos pasos:&lt;/p&gt;

&lt;p&gt;1 - Invocar el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;git-fetch&lt;/code&gt;, que sincroniza los contenidos de las ramas &lt;code class=&quot;highlighter-rouge&quot;&gt;origin/*&lt;/code&gt; en local, sin llevárselos a las versiones locales. Lo sé, es confuso, pero espero que lo entendáis mejor con el diagrama:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-remotes-5.jpg&quot; alt=&quot;Git remotes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fijaos en que &lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt;, ha pasado del commit (1) al (2), es decir, nuestro Git local ya está al tanto de los nuevos cambios en remoto. Viendo la salida de &lt;code class=&quot;highlighter-rouge&quot;&gt;show-ref&lt;/code&gt;, podemos ver cómo los commits de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt; son diferentes:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git show-ref master
9232aacf90cd50182e7608b5b051250c97ab109d refs/heads/master
0e0a1c2800d295e25b7766a8b66fc681be3a2f07 refs/remotes/origin/master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;2 - Hacer un merge de las ramas &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge origin/master&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-remotes-6.jpg&quot; alt=&quot;Git remotes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Vemos que ahora hemos resuelto el problema, ya que el “merge commit” tiene como padre el último commit en la rama remota &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;. Por lo que si nadie ha añadido nuevos commmits en dicha rama, ahora sí, podremos hacer &lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt; sin problemas.&lt;/p&gt;

&lt;p&gt;En realidad, estas dos acciones pueden llevarse a cabo de una, con el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;, que seguro todos conocéis. En su versión por defecto, este comando no hace más que un fetch + merge, de la forma en que hemos visto.&lt;/p&gt;

&lt;p&gt;Si recordáis &lt;a href=&quot;/2017/03/como-funciona-git-3/&quot;&gt;el anterior artículo&lt;/a&gt;, podemos utilizar rebase como alternativa a merge para fusionar ramas. Esto tiene ventajas y desventajas, no olvidéis que vamos a reescribir la historia, pero en el caso de que vayamos añadiendo sucesivos commits en nuestra versión local, antes de hacer push me parece una buena práctica hacer un rebase de la &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; remota en lugar del merge que hemos visto. Así conseguiremos una historia más limpia, sin merge commits innecesarios y sin ramas cruzándose.&lt;/p&gt;

&lt;p&gt;Para conseguir esto, aunque es posible hacer fetch + rebase, la forma rápida es mediante el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull --rebase&lt;/code&gt;. En nuestro ejemplo, si hiciéramos esto en lugar de pull sin más, la foto final quedaría así:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-remotes-7.jpg&quot; alt=&quot;Git remotes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Siendo ahora el commit (2) exactamente el mismo que existe en el &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; remoto, y (3) una reescritura llevada a cabo durante la operación de rebase. Para terminar, sería necesario sincronizarlo todo con &lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-remotes-8.jpg&quot; alt=&quot;Git remotes&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;escenario-3-lo-mismo-pero-con-conflictos&quot;&gt;Escenario 3: lo mismo, pero con conflictos&lt;/h3&gt;

&lt;p&gt;Si surgen conflictos durante las operaciones de merge o rebase, no hay ninguna diferencia entre el proceso que se lleva a cabo para solucionarlos durante una sincronización con el repositorio remoto respecto a lo que ocurre durante una fusión entre ramas. Por tanto, os remito de nuevo a la breve descripción al respecto que aparecía &lt;a href=&quot;/2017/03/como-funciona-git-3/&quot;&gt;en el anterior post de la serie&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusiones&quot;&gt;Conclusiones&lt;/h2&gt;

&lt;p&gt;Espero que esta seria os haya servido de ayuda para perder el miedo a Git. Personalmente, conocer todos estos detalles sobre el funcionamiento de la herramienta ha conseguido que cuando surge un conflicto no pierda los nervios de forma inmediata, como sí me ocurría antaño :).&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Cómo trabajamos en Pivotal</title>
   <link href="http://www.raulavila.com/2017/04/como-trabajamos-pivotal/"/>
   <updated>2017-04-06T00:00:00+01:00</updated>
   <id>http://www.raulavila.com/2017/04/como-trabajamos-pivotal</id>
   <content type="html">&lt;p&gt;Hace algo más de un año comencé a trabajar en &lt;a href=&quot;https://pivotal.io/&quot;&gt;Pivotal&lt;/a&gt;, una empresa donde no he dejado de aprender desde el día uno. A finales de 2016, tras descubrir la web &lt;a href=&quot;http://www.wedotdd.com/&quot;&gt;We Do TDD&lt;/a&gt; (una gran iniciativa) y unirme al canal de Slack, se me ofreció la posibilidad de ser entrevistado para describir la forma en que trabajamos, cómo utilizamos TDD, etc. Acepté en paralelo al mismo tiempo que un compañero de Berlín (Oleksii, más conocido como &lt;a href=&quot;http://www.tddfellow.com/&quot;&gt;That TDD Fellow&lt;/a&gt;), por lo que decidimos hacer la entrevista conjunta, cosa que, por otra parte, encaja bastante bien con la cultura de nuestra empresa, donde el pair programming es una constante.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.wedotdd.com/interviews/companies/22&quot;&gt;La entrevista fue publicada recientemente&lt;/a&gt;, y me he permitido la licencia de publicar un post con la única intención de publicitarla :).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.wedotdd.com/interviews/companies/22&quot;&gt;Entrevista en We Do TDD (en inglés)&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>La comunicación en proyectos Software</title>
   <link href="http://www.raulavila.com/2017/04/comunicacion-proyectos-software/"/>
   <updated>2017-04-01T00:00:00+01:00</updated>
   <id>http://www.raulavila.com/2017/04/comunicacion</id>
   <content type="html">&lt;p&gt;Esta semana hará tres meses que inicié mi andadura como Anchor en un proyecto de mi empresa. Diría que la experiencia está siendo muy buena en todos los sentidos, y me está sirviendo para aprender un montón de cosas. Quizás la más importante de todas ellas sea como gestionar la comunicación dentro de un equipo de forma eficiente, y en este post voy a repasar muchas de las conclusiones que he ido sacando en claro.&lt;/p&gt;

&lt;!--break--&gt;

&lt;h2 id=&quot;comunicación-síncrona&quot;&gt;Comunicación síncrona&lt;/h2&gt;

&lt;p&gt;Comunicación síncrona es aquella en la que el intercambio de mensajes e impresiones ocurre en tiempo real, lo que incluye:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Conversaciones directas en persona&lt;/li&gt;
  &lt;li&gt;Conversaciones telefónicas&lt;/li&gt;
  &lt;li&gt;Reuniones&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;conversaciones-en-persona&quot;&gt;Conversaciones en persona&lt;/h3&gt;

&lt;p&gt;Es, en mi opinión, el canal más importante de comunicación, y el que debe funcionar con mayor fluidez. Me atrevería a afirmar con rotundidad que ninguna forma de comunicación supera al intercambio de impresiones entre dos personas realmente implicadas en la discusión, y es por eso que seguiré defendiendo a capa y espada el &lt;a href=&quot;/2016/08/pair-programming/&quot;&gt;Pair Programming&lt;/a&gt;. Me resulta gracioso pensar ahora que el trabajar con Pair Programming casi el 100% del tiempo me hizo dudar un poco antes de unirme a una empresa que lo practicaba, mientras que en este momento de mi carrera creo que difícilmente aceptaría una oferta de desarrollador para una empresa donde no se practique.&lt;/p&gt;

&lt;p&gt;Fuera del Pair Programming, las conversaciones en persona deben ocurrir siempre que sea necesario, y para ello es fundamental tener al equipo trabajando en el mismo espacio, a poder ser con pizarras compartidas donde se puedan esbozar ideas y diagramas con facilidad. Es importante ser respetuosos con el trabajo de los demás si nos dirigimos a una persona para discutir o preguntar algo, con esto quiero decir que nunca interrumpáis directamente sin antes preguntar con educación “¿Tienes un segundo?” o similar. Si no es el momento adecuado, debemos entenderlo y esperar. La &lt;a href=&quot;https://es.wikipedia.org/wiki/T%C3%A9cnica_Pomodoro&quot;&gt;Técnica Pomodoro&lt;/a&gt; puede ser realmente útil en este punto, de forma que durante un pomodoro no es posible interrumpir lo que alguien esté haciendo.&lt;/p&gt;

&lt;p&gt;También creo que es importante no desviarse demasiado del tema de discusión principal. Ocurre en ocasiones que se empieza tratando un punto A, y en mitad de la conversación saltamos a B, luego a C, y terminamos en F después de una hora. Esta conversaciones no suelen ser excesivamente productivas (¡aunque siempre hay excepciones!), y es importante rectificar el curso si detectamos una pérdida de rumbo excesiva.&lt;/p&gt;

&lt;h3 id=&quot;conversaciones-telefónicas&quot;&gt;Conversaciones telefónicas&lt;/h3&gt;

&lt;p&gt;No me extenderé mucho aquí, ya que el uso del teléfono en mi empresa es CERO. Esto es posible porque siempre presionamos para tener al equipo completo en el mismo espacio (como acabo de mencionar). En cualquier caso, por mi experiencia pasada sí tengo algo que aportar a este punto, y es que se deberían evitar tanto como sea posible las llamadas telefónicas “a puerta fría”, es decir, sin aviso previo, sobre todo si es para tratar un tema más o menos en profundidad (como por ejemplo realizar un seguimiento por parte de un manager que esté en otra oficina). Este tipo de llamadas tienen un impacto muy grande en el trabajo que el receptor de la llamanda pueda estar realizando, y creo que deberían programarse en el calendario de la misma forma que una reunión presencial de seguimiento.&lt;/p&gt;

&lt;p&gt;Otro de los grandes problemas de las conversaciones telefónicas es que son efímeras y no suelen dejar ningún rastro. La memoria humana no es perfecta y es caprichosa, pudiendo crear todo tipo de confusiones.&lt;/p&gt;

&lt;p&gt;El único caso donde creo que se pueden justificar las llamadas telefónicas repentinas es cuando está ocurriendo una incidencia grave que requiere atención inmediata.&lt;/p&gt;

&lt;h3 id=&quot;reuniones&quot;&gt;Reuniones&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/2015/04/reuniones/&quot;&gt;Ya toqué este tema&lt;/a&gt; hace un par de años, pero creo que estoy en posición de añadir nuevas puntualizaciones a lo que entonces dije.&lt;/p&gt;

&lt;p&gt;Siendo franco, yo siempre he detestado las reuiones. Opinaba que en la mayoría de los casos no sirven para gran cosa, pero esa perspectiva ha cambiado ligeramente desde que ya no trabajo en desarrollo el 100% del tiempo. Mi punto de vista en la actualidad es que las reuniones son necesarias &lt;strong&gt;mientras sean productivas&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Empezaré con unas puntualizaciones rápidas sobre las reuniones fijas que suelen existir en casi todos los procesos ágiles:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Stand-up: debería tener lugar a primera hora de la mañana. Quizás no a las 9 en punto, para no forzar una puntualidad excesiva y el consiguiente estrés asociado en las grandes ciudades, pero definitivamente antes de las 10. Esta reunión debe ser &lt;strong&gt;corta&lt;/strong&gt;, así que por favor, evitad dar detalles técnicos innecesarios sobre lo que hicísteis el día anterior, y que dependiendo del tamaño del equipo puede estirar la duración de la stand-up hasta unos 40 minutos (!!!). El principal cometido de la stand-up debería ser compartir a grooso modo el trabajo que estamos haciendo, y lanzar preguntas sobre determinados temas que nos puedan estar bloqueando.&lt;/li&gt;
  &lt;li&gt;Reunión de planificación: en mi empresa las iteraciones son de una semana, y la reunión de planificación dura una hora. Las historias de usuario deberían llegar tan maduradas como sea posible en cuanto a la descripción y los criterios de aceptación, de forma que el equipo pueda puntuar el máximo número posible. En mi experiencia, lleva un tiempo agilizar este proceso.&lt;/li&gt;
  &lt;li&gt;Retrospectivas: dura otra hora, y repasamos las cosas buenas, malas, y reguleras que han ocurrido durante la semana, centrándonos sobre todo en sentimientos (lo cual representamos con tres columnas: cara sonriente, cara triste, y meh). En esta reunión debemos ser tan abiertos y claros como sea posible, y lo más importante de todo, &lt;strong&gt;debemos extraer acciones a tener en cuenta para la siguiente iteración&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Todas estas reuniones no deberían llevar más de 3 horas por semana a todo el equipo. El principal problema de muchos proyectos, y donde creo que hay que poner el foco, son las reuniones que caen fuera de este grupo. Intentaré resumir los anti-patrones que, a mi parecer, debemos evitar:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Demasiada gente convocada: no, no hace falta que todos los desarrolladores estén presentes en reuniones para discutir temas como las proyecciones de futuras fechas de entrega (el típico roadmap), el descubrimiento de nuevos requisitos, la toma de decisiones con la división de seguridad da empresa, etc. El tiempo que los desarrolladores están, ejem, desarrollando, debería maximizarse tanto como sea posible, y para eso existen roles (llámese Team Leader, Anchor, o lo que sea), cuya labor es proteger al equipo de estas conversaciones.&lt;/li&gt;
  &lt;li&gt;Reuniones sin decisión de acciones asociada: toda reunión debe terminar con acciones a seguir por una o más personas (que puede incluso ser todo el equipo). Estas decisiones deberían quedar reflejadas en algún sitio (JIRA, Pivotal Tracker, Trello), y no sólo en los cuadernos de los asistentes. En ocasiones, dependiendo de la audiencia, es recomendable enviar un correo a modo de resumen con estas acciones.&lt;/li&gt;
  &lt;li&gt;Reuniones de larga duración sin breaks: sinceramente, yo soy incapaz de mantener la atención de manera continuada durante más de 70 minutos. No digo esta cifra al azar, en mi experiencia, a la hora y cuarto no puedo seguir conectado. Los descansos son necesarios, y ni siquiera necesitamos que sean muy largos, 5-10 minutos cada hora, no solo no restan, sino que suman efectividad a la reunión.&lt;/li&gt;
  &lt;li&gt;Reuniones sin preparación previa: nunca debemos ir a una reunión sin preparar por encima el tema que se va a tratar. Sin preparación, alguno de los presentes tendrá mucho más contexto que nosotros, tomará la batuta de la discusión, y la reunión avanzará sin discusión real, puesto que no nos atreveremos a rebatir sus argumentos por miedo a quedar en ridículo.&lt;/li&gt;
  &lt;li&gt;Reuniones con varias personas en remoto: esto no es fácil de evitar en muchas ocasiones, pero el hecho de tener gente en otra localización diferente (presente al teléfono o Skype) dificulta mucho determinadas conversaciones, además de hacer imposible el uso de la pizarra física si fuera necesaria. Repito, un punto difícil de evitar, pero que conviene mencionar.&lt;/li&gt;
  &lt;li&gt;Reuniones que se desvían del tema principal: aspecto que ya comenté en la comunicación entre personas de este mismo artículo, pero que cobra una dimensión incluso mayor en las reuniones. Si nos desvíamos en exceso del tema principal, pueden que gastemos el tiempo de la reunión por completo sin llegar a ningún lado. De ahí la importancia de establecer una agenda clara, y mantener la conversación enfocada.&lt;/li&gt;
  &lt;li&gt;Gente con el portátil / móvil en la sala: aspecto peliagudo de evitar, debido al funcionamiento de muchas empresas. El mayor problema que veo a esto es que, quizás debido a las &lt;a href=&quot;https://es.wikipedia.org/wiki/Neurona_especular&quot;&gt;neuronas espejo&lt;/a&gt;, cuando alguien empieza a interactuar con su ordenador o teléfono, siempre hay gente que va detrás :), lo cual nos lleva a la pregunta de si es realmente necesario que esas personas estén presentes en la reunión.&lt;/li&gt;
  &lt;li&gt;Personas presentes la reunión entera que sólo son necesarios para un punto en concreto: esta guerra la llevo luchando desde que trabajaba en España hace años. Por aquel entonces, mi empresa se dedicaba a la consultoría medioambiental, y yo era el programador de las webs que desarrollábamos. Pues bien, llegué a tragarme reuniones de 5 horas donde las 4 primeras se centraban en normativas y legislaciones, temas que ni me iban ni me venían, y en la última hora pasábamos a discutir los aspectos de la web. Hay que intentar optimizar el tiempo que la gente pasa en reuniones, y no debería estar mal visto para nada el hecho de que una persona empiece en la reunión y la abandone a los 10-20 minutos de empezar, cosa que, por algún extraño motivo, parece realmente complicado de implementar.&lt;/li&gt;
  &lt;li&gt;Timing: las reuniones deben convocarse con un tiempo razonable, para permitir prepararla a los asistentes, y si la reunión pasa a ser innecesaria por algún motivo debe cancelarse tan pronto lo sepamos. La cancelación tardía de reuniones (no es infrecuente recibir cancelaciones una hora o incluso cinco minutos antes de la reunión) puede resultar muy contraproducente para todos los invitados, que quizás hayan planeado su mañana o tarde en torno a ese evento.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;comunicación-asíncrona&quot;&gt;Comunicación asíncrona&lt;/h2&gt;

&lt;p&gt;A diferencia de la comunicación síncrona, en la asíncrona enviamos un mensaje sin esperar respuesta inmediata. Esta forma de comunicación es quizás menos fluida, pero sin embargo no tiene un impacto tan directo en la productividad, ya que queda en cada persona como manejar estos canales. Las dos herramientas principales dentro de esta categoría son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mensajería instantánea&lt;/li&gt;
  &lt;li&gt;Email&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mensajería-instantánea&quot;&gt;Mensajería instantánea&lt;/h3&gt;

&lt;p&gt;No hay empresa que no tenga un sistema de este tipo, llámese Lync, Hipchat o Slack, aunque parece que este último está monopolizando esta categoría últimamente.&lt;/p&gt;

&lt;p&gt;No tengo gran cosa que aportar en esta categoría, quizás resaltar la necesidad de crear canales específicos dentro de un proyecto determinado, de forma que los desarrolladores no discutan temas técnicos en el canal principal (a la vista de Product Managers y gente de negocio), por ejemplo.&lt;/p&gt;

&lt;p&gt;Personalmente, no utilizo la mensajería instantánea muy a menudo, ya que donde realmente es útil es en proyectos donde el equipo está distribuido, lo cual nunca ha sido mi caso.&lt;/p&gt;

&lt;p&gt;Un último consejo: todas las empresas tienen acceso al registro de las conversaciones que dejéis en este tipo de sistemas, así que cuidado con las cosas que digáis :D.&lt;/p&gt;

&lt;h3 id=&quot;email&quot;&gt;Email&lt;/h3&gt;

&lt;p&gt;Existen varias consideraciones a tener en cuenta sobre el uso del correo electrónico. La verdad es que este tema daría para un libro, pero intentaré condensar los puntos más importantes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;No asumas que la gente va a leer tu correo: en efecto, la gente está muy ocupada, recibe muchos correos, y muchas veces no tiene tiempo que dedicarle a ese mensaje que tú crees es de importancia capital. El mayor riesgo en este punto es que un correo se quede marcado como leído en la bandeja de entrada sin que ese hecho haya ocurrido realmente. Para mitigar el riesgo de que tu correo sea ignorado, es crucial intentar ser conciso, el efecto “correo marcado como leído sin leer” es más probable cuanto más largo sea el correo. Otra forma de mitigar esto es marcar en negrita una pregunta o aspecto concreto que sea de importancia capital y/o necesite una respuesta en algún momento.&lt;/li&gt;
  &lt;li&gt;La gente reenvía los correos: no creo que os pille por sorpresa, pero lo menciono por si acaso, para que no lo olvidéis. Las consecuencias más nefastas que he experimentado en mi carrera a este respecto es cuando alguien reenvía una conversación kilométrica para que el destinatario eche un vistazo al email más reciente de la cadena, y se da la situación de que en algún punto de la discusión se hablan de temas, digamos “delicados”. Es por esto que debemos ser extremadamente cuidadosos con lo que escribimos en nuestros emails, evitando en la medida de lo posible la ironía, el sarcasmo, y menciones a terceros que se salgan de la objetividad y contengan un componente emocional.&lt;/li&gt;
  &lt;li&gt;Si tienes tres preguntas que hacer, envía tres correos: los correos son leídos normalmente a gran velocidad, y si el correo contiene varias preguntas es probable que no todas sean respondidas (si es que alguna es respondida). Por ello debemos centrarnos en un aspecto muy concreto del que necesitemos aclaración en cada correo, y si queremos incrementar la probabilidad de respuesta, podemos marcarlo en negrita. Una vez leí en un artículo que la mejor forma de incrementar las probabilidades de que el destinatario de un correo responda a una petición es finalizando con “Gracias por adelantado”. No estoy en posición de defender la fiabilidad de esto, pero ahí lo dejo :).&lt;/li&gt;
  &lt;li&gt;Relee y relee antes de escribir, a poder ser en voz alta, o mejor, pide a otra persona que lo relea contigo. Esto ayuda mucho a detectar frases poco claras, falta de información, o a corregir el tono incorrecto en algún punto tratado.&lt;/li&gt;
  &lt;li&gt;Si necesitamos adjuntar un documento importante que pueda evolucionar en el tiempo, plantearos la necesidad de poner ese documento en un espacio compartido (Confluence, Google Drive…), de forma que no se generen confusiones con diferentes versiones circulando. Si no queda otra que adjuntarlo, añadid un número de versión, y madurad bien el documento antes de pulsar “Send”, quizás dejando el correo escrito una tarde y revisándolo en la mañana siguiente antes de enviar.&lt;/li&gt;
  &lt;li&gt;El correo electrónico no es un chat, nunca esperes que la gente responda inmediatamente. Evita en la medida de lo posible el envío de correos para preguntar si un correo anterior ha sido leído, y de hacerlo, deja pasar un tiempo prudencial (no menos de una semana / 10 días).&lt;/li&gt;
  &lt;li&gt;Nunca dejes un tema de gran importancia a expensas de recibir respuesta a un correo, utiliza otros canales para esto.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Con esto termino mi repaso a las diferentes formas de comunicación en proyectos de empresa. Si pensáis que me he dejado alguna, o si creéis necesario puntualizar algún aspecto de los tratados, estaré encantado de seguir discutiendo en los comentarios.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Cómo funciona Git (parte 3)</title>
   <link href="http://www.raulavila.com/2017/03/como-funciona-git-3/"/>
   <updated>2017-03-11T00:00:00+00:00</updated>
   <id>http://www.raulavila.com/2017/03/como-funciona-git-3</id>
   <content type="html">&lt;p&gt;Continuamos con nuestra serie sobre el funcionamiento interno de Git. &lt;a href=&quot;/2017/02/como-funciona-git-2/&quot;&gt;En el anterior post&lt;/a&gt; dejamos nuestro repositorio en el siguiente estado:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-head.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;!--break--&gt;

&lt;p&gt;Es hora de revisar como funcionan dos de los comandos más utilizados (y más temidos también): &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;merge&quot;&gt;Merge&lt;/h2&gt;

&lt;p&gt;Git merge significa algo así como “fusiona los contenidos de ambas ramas, utilizando la mejor estrategia posible, y añadiendo un nuevo commit en caso necesario”. No pretendo entrar en detalles de &lt;a href=&quot;https://git-scm.com/docs/merge-strategies&quot;&gt;todas las estrategias que se pueden utilizar&lt;/a&gt;, tan sólo cubriré los casos más frecuentes.&lt;/p&gt;

&lt;h4 id=&quot;fast-forward&quot;&gt;Fast-forward&lt;/h4&gt;

&lt;p&gt;Veamos que ocurre si queremos fusionar las dos ramas en el estado que tenemos ahora mismo:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git branch
  develop
* master

$ git merge develop
Already up-to-date.

$ git checkout develop
Switched to branch 'develop'

$ git merge master
Updating 284c288..aa90e47
Fast-forward
 goodbye.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 goodbye.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;Intentamos fusionar &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt; en &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;, pero Git nos dice que la rama &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; ya está actualizada. Esto es así porque la historia en &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; va por delante de la historia en &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;, siendo el último commit en &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; un sucesor del último commit en &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;. Es decir, no hay nada que hacer, porque evidentemente Git no va a eliminar nuevos commits de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; para fusionarla con &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Nos vamos a &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt; y la fusionamos con &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;. Vemos que Git ejecuta la tarea utilizando la estrategia “fast-forward”. Esto significa que Git ha detectado que la historia de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; que no está en &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt; tiene como ancestro el último commit de &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;, por lo que solamente necesita mover el puntero de la rama (arrastrando HEAD con él) hasta el último commit de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;. Tras realizar esta acción el contenido de Git queda así:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-fast-forward.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;recursive&quot;&gt;Recursive&lt;/h4&gt;

&lt;p&gt;Para explicar correctamente la siguiente estrategia de merge volvamos a la versión anterior de nuestro repositorio, es decir:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-head.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Es interesante recordar lo que tenemos en ambas ramas también:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git branch
  develop
* master

$ tree
.
├── goodbye.txt
├── greetings
│   └── hello2.txt
└── hello.txt

1 directory, 3 files

$ git checkout develop
Switched to branch 'develop'

$ tree
.
├── greetings
│   └── hello2.txt
└── hello.txt

1 directory, 2 files&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Siendo breves, en &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; tenemos un commit que añade el fichero &lt;code class=&quot;highlighter-rouge&quot;&gt;goodbye.txt&lt;/code&gt;, commit que no tenemos en &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;. Vamos a añadir un nuevo commit en la rama &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ echo &quot;Greeting develop&quot; &amp;gt; goodbye_develop.txt

$ git add .

$ git commit -m &quot;New commit in develop&quot;
[develop ac88e5b] New commit in develop
 1 file changed, 1 insertion(+)
 create mode 100644 goodbye_develop.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Tras este commmit se nos queda el siguiente dibujo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-merge-1.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Como veis, ambas ramas han “divergido”, partiendo de un ancestro común (el commit &lt;code class=&quot;highlighter-rouge&quot;&gt;284c28&lt;/code&gt;). Vamos a hacer merge de la rama &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; dentro de &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git merge master
Merge made by the 'recursive' strategy.
 goodbye.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 goodbye.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Git ha utilizado la estrategia “recursive”. Esta es la historia que ha quedado en &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;*   01c72ea 2017-03-11 | Merge branch 'master' into develop (HEAD -&amp;gt; develop) [RaulAvila]
|\
| * aa90e47 2017-02-11 | Third commit (master) [RaulAvila]
* | ac88e5b 2017-03-11 | New commit in develop [RaulAvila]
|/
* 284c288 2017-02-11 | Second commit [RaulAvila]
* d1ee121 2017-01-22 | First commit (tag: first) [RaulAvila]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Si os fijáis bien, se ha añadido un nuevo commit del tipo “merge commit”. La gran diferencia entre un commit normal y uno de tipo “merge”, es que en este último existen dos ancestros, cosa que podemos ver fácilmente con el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;cat-file&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git cat-file -p 01c72ea
tree 77f9b4b34bc364b29ac12fec827985384d469ddd
parent ac88e5b089928490ff498f63218687ded7b57c87
parent aa90e471ababde242281c833fffea255f69dd28a
author RaulAvila &amp;lt;xxxxxx@gmail.com&amp;gt; 1489226224 +0000
committer RaulAvila &amp;lt;xxxxxx@gmail.com&amp;gt; 1489226224 +0000

Merge branch 'master' into develop&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Así nos queda nuestro “árbol” de Git, tras esta operación:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-merge-2.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La rama &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; no sabe nada de lo que ha ocurrido en &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;. En teoría podríamos continuar añadiendo nuevos commits en &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; y hacerla evolucionar de manera independiente. Pero en proyectos reales, lo más normal en estos casos es sincronizar ambas ramas, lo que en este caso es tan sencillo como hacer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git checkout master
Switched to branch 'master'

$ git merge develop
Updating aa90e47..01c72ea
Fast-forward
 goodbye_develop.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 goodbye_develop.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Espero que tenga sentido lo que ha ocurrido ahora, Git ha detectado el merge que tuvo lugar en develop, por lo que para fusionar &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt; en &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; le basta con hacer un fast-forward, moviendo el puntero de la rama al “merge commit”, es decir:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-merge-3.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Por cierto, tras todo este proceso, nuestro repositorio ha quedado tal que así:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ tree
.
├── goodbye.txt
├── goodbye_develop.txt
├── greetings
│   └── hello2.txt
└── hello.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;rebase&quot;&gt;Rebase&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;Git rebase&lt;/a&gt; es uno de los comandos más potentes de Git, pero también el más peligroso. No es más que una forma diferente de fusionar el contenido de dos ramas, siguiendo una estrategia bastante agresiva: reescribir la historia, sin añadir ningún commit adicional, como sí hacía merge. El mejor articulo para entender las diferencias entre &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt; &lt;a href=&quot;https://www.atlassian.com/git/tutorials/merging-vs-rebasing&quot;&gt;es este&lt;/a&gt;, no es mi intención cubrir con mucho detalle algo que ya se ha discutido hasta la saciedad, sino mostrar cuál es el proceso interno en el repositorio de Git.&lt;/p&gt;

&lt;p&gt;Veamos pues qué ocurre cuando hacemos &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;, y para ello partiremos de este estado anterior:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-merge-1.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git branch
* develop
  master

$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: New commit in develop&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Leemos dos mensajes:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;“Rewinding head to replay your work on top of it”: Git busca el ancestro común de ambas ramas (el commit &lt;code class=&quot;highlighter-rouge&quot;&gt;284c28&lt;/code&gt;), y mueve el puntero &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; por la historia de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; hasta el último commit que encuentre allí (que es &lt;code class=&quot;highlighter-rouge&quot;&gt;aa90e4&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;“Appying: New commit in develop”: Git comienza a leer la historia de &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt; a partir del ancestro común (recordemos, &lt;code class=&quot;highlighter-rouge&quot;&gt;284c28&lt;/code&gt;), y commit a commit, lee el contenido de cada uno de ellos (los commits pueden contener trees, blobs… &lt;a href=&quot;/2017/01/como-funciona-git-1/&quot;&gt;leed la primera parte de la serie si no sabéis a qué me refiero&lt;/a&gt;), y genera, para cada commit,  &lt;strong&gt;un nuevo commit&lt;/strong&gt; con exactamente el mismo contenido, pero con un ancestro diferente, puesto que los va situando encima del todo en la historia, tras el último commit de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;. Recordemos que los commits en Git son inmutables, por lo que si cambia el ancestro, aún manteniendo el contenido, hay que generar un nuevo commit. En realidad no sólo cambia el ancestro, también la fecha, que contendrá el día y hora en que ejecutamos el rebase.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Como sólo tenemos un commit en &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt; que no esté en &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;, Git generará un nuevo commit con el mismo contenido, pero teniendo como ancestro a &lt;code class=&quot;highlighter-rouge&quot;&gt;aa90e4&lt;/code&gt; (el último commit de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;). Este nuevo commit tendrá un hash diferente, ya que su fecha/hora y ancestro han cambiado, aún compartiendo contenido (en el caso que nos ocupa, el nuevo hash es &lt;code class=&quot;highlighter-rouge&quot;&gt;3e7eed&lt;/code&gt;). Si hubiera más de un commit en &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt; se seguiría reescribiendo la historia, de forma que un segundo commit se añadiría encima de &lt;code class=&quot;highlighter-rouge&quot;&gt;3e7eed&lt;/code&gt;, y así sucesivamente.&lt;/p&gt;

&lt;p&gt;Nuestro árbol de Git queda así:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-rebase-1.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;No he dejado el commit &lt;code class=&quot;highlighter-rouge&quot;&gt;284c28&lt;/code&gt; por error. Este es el commit que anteriormente pertenecia a &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;, pero ha dejado de hacerlo tras el rebase, momento en que ha sido reemplazado por &lt;code class=&quot;highlighter-rouge&quot;&gt;3e7eed&lt;/code&gt;, que tiene el mismo contenido pero distinto ancestro. El hecho de que tengamos un commit sin ninguna rama que lo referencia significa que en algún momento el recolector de basura de Git lo eliminará de su base de datos. Pero si no queremos que eso ocurra siempre podemos crear una rama apuntando a él, recordad que una rama no es más que un puntero a un commit. Es decir, podríamos hacer esto:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git checkout 284c28
Note: checking out '284c28'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &amp;lt;new-branch-name&amp;gt;

HEAD is now at 284c288... Second commit

$ git checkout -b backup
Switched to a new branch 'backup'&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Y desde ahora siempre tendremos una referencia a nuestra rama &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt; antes del &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;. De hecho conozco a gente que antes de hacer un rebase se crea una rama backup de esta forma desde la propia &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;, de forma que si el rebase fracasa estrepitosamente siempre se mantiene la referencia del punto de partida:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-rebase-2.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;En este punto supongo que sabríais decirme lo que ocurriría si nos vamos a master y hacemos &lt;code class=&quot;highlighter-rouge&quot;&gt;git merge develop&lt;/code&gt;, ¿verdad?:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git merge develop
Updating aa90e47..3e7eed9
Fast-forward
 goodbye_develop.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 goodbye_develop.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;En efecto, mediante un sencillo fast-forward, el puntero de &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; se mueve al mismo commit que completa la rama &lt;code class=&quot;highlighter-rouge&quot;&gt;develop&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;resolución-de-conflictos&quot;&gt;Resolución de conflictos&lt;/h2&gt;

&lt;p&gt;En la práctica, hacer &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt; no es tan bonito ni sencillo como acabo de representar, y normalmente tendremos que resolver &lt;a href=&quot;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&quot;&gt;los temidos conflictos&lt;/a&gt;. No voy a entrar en detalles sobre este tema, no es el objetivo de estos posts, tan solo añadir un par de puntualizaciones:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Si el conflicto ocurre durante un merge donde se está aplicando la estrategia “recursive”, lo que ocurre al resolver los conflictos es que los cambios que generemos al resolverlos se añadirán al contenido (“blob”) del merge commit.&lt;/li&gt;
  &lt;li&gt;Si el conflicto ocurre durante un rebase, Git se quejará mientras aplica uno de los commits según va reescribiendo la historia, y parará de reescribir hasta que lo arreglemos. Una vez solucionado, y tras continuar con el rebase (&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase --continue&lt;/code&gt;) los cambios se añadirán al contenido del commit que se estaba reescribiendo, por lo que en este caso se dará la situación de que un commit “reescrito” no tiene el mismo contenido que el original.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Repito, esta explicación es muy “a grosso”, y entrar en detalles requeriría un artículo en condiciones.&lt;/p&gt;

&lt;p&gt;Finalizo aquí este post de la serie. Mi intención inicial era cubrir la forma en que Git trabaja con repositorios remotos, pero creo que desembocaría en un artículo demasiado largo y poco cohesionado. Así que lo haré en el siguiente, y ahora sí, &lt;a href=&quot;/2017/04/como-funciona-git-4/&quot;&gt;último post de la serie&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>The Senior Software Engineer (el libro)</title>
   <link href="http://www.raulavila.com/2017/02/senior-software-engineer-book/"/>
   <updated>2017-02-26T00:00:00+00:00</updated>
   <id>http://www.raulavila.com/2017/02/senior-software-engineer</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;/public/pictures/sse.jpg&quot; alt=&quot;SSE&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Acabo de terminar el libro &lt;a href=&quot;https://www.amazon.co.uk/Senior-Software-Engineer-Practices-Effective/dp/0990702804/ref=sr_1_1?&quot;&gt;“The Senior Software Engineer: 11 Practices of an Effective Technical Leader”&lt;/a&gt;, escrito por David Bryant Copeland, y me ha gustado tanto que he decidido dedicarle un breve post para animaros a leerlo.&lt;/p&gt;

&lt;p&gt;El libro me lo recomendaron en el foro interno de mi empresa, como guía para enfocar correctamente el nuevo rol que me ha tocado este año, pero una vez finalizado, me atrevo a decir que más que una guía para Technical Leaders es un playbook para que un programador con algo de experiencia (pongamos un par de años) sepa encarrilar los siguientes pasos de su carrera.&lt;/p&gt;

&lt;!--break--&gt;

&lt;h2 id=&quot;resultados&quot;&gt;Resultados&lt;/h2&gt;

&lt;p&gt;El autor comienza hablando de la importancia de entregar resultados en nuestro puesto de trabajo. Esto es algo con lo que me identifico de pleno, creo que se malgasta muchísimo tiempo en la oficina, con conversaciones infructuosas, &lt;a href=&quot;/2015/04/reuniones/&quot;&gt;reuniones&lt;/a&gt; interminables de las que no se saca ninguna acción en concreto, implementación de nuevas funcionalidades que introducen un montón de bugs y restan más que suman, etc.&lt;/p&gt;

&lt;p&gt;Se describe cómo es mucho mejor tardar más tiempo en responder un email con una respuesta concreta que responder rápidamente con un “ya te miro esto”. Quizás lo primera cause algo de ansiedad en la persona que nos está preguntando o pidiendo algo, pero tras comprobar la consistencia con la que respondemos de forma clara y concisa pasado un tiempo, nuestra reputación nos empezará a preceder, eliminando este factor.&lt;/p&gt;

&lt;h2 id=&quot;tdd&quot;&gt;TDD&lt;/h2&gt;

&lt;p&gt;Los siguientes capítulos se centran en el proceso a seguir para solucionar bugs e implementar nuevas funcionalidades en un sistema existente. Para conseguir la máxima efectividad el proceso recomendado no es otro que &lt;a href=&quot;/2015/08/primera-experiencia-tdd/&quot;&gt;Test Driven Development&lt;/a&gt;. La gran diferencia entre solucionar un simple bug y añadir una nueva feature al sistema es el papel de los tests de aceptación en el proceso, que en el caso de los bugs no suelen hacer acto de presencia, aunque yo añadiría que dependiendo del bug podrían hacerlo.&lt;/p&gt;

&lt;p&gt;En segundo lugar es muy importante una comunicación constante con las diferentes partes implicadas en nuestro proyecto (stakeholders en inglés). Un canal defectuoso aquí puede tener consecuencias muy negativas en el resultado entregado.&lt;/p&gt;

&lt;p&gt;Se hace también hincapié en la importancia de las revisiones de código antes de liberar el código. &lt;a href=&quot;/2015/03/code-reviews/&quot;&gt;Yo hablé de esto&lt;/a&gt; hace un par de años, aunque en este punto de mi carrera creo que el &lt;a href=&quot;/2016/08/pair-programming/&quot;&gt;Pair Programming&lt;/a&gt; es más efectivo.&lt;/p&gt;

&lt;p&gt;Para terminar, conviene no perder de vista el riesgo de una optimización excesiva (over-engineering) en la fase de refactoring en el proceso TDD. Esto es algo en lo que yo he caído más de una vez. El refactoring debe ser un medio para conseguir nuestros objetivos, y no un fin. En uno de los apéndices se trata de forma explícita este tema de nuevo, bajo el título “Refactoring Responsable”.&lt;/p&gt;

&lt;h2 id=&quot;deuda-técnica&quot;&gt;Deuda técnica&lt;/h2&gt;

&lt;p&gt;Se describe la diferencia entre Deuda Técnica y “Código chapucero” (sloppy code), que en mi opinión es bastante importante. Todos sabemos cuando no estamos poniendo el suficiente empeño en generar código mantenible, pero en ocasiones es necesario incurrir en deuda técnica porque es la mejor decisión que se puede tomar en ese momento dadas las circunstancias.&lt;/p&gt;

&lt;p&gt;Podéis encontrar cientos de referencias sobre &lt;a href=&quot;https://martinfowler.com/bliki/TechnicalDebt.html&quot;&gt;Deuda Técnica&lt;/a&gt; en Internet, y conviene que sepáis manejar convenientemente este concepto si os dedicáis profesionalmente al Software. En pocas palabras, deuda técnica es un compromiso que estamos tomando en forma de decisión técnica, para cumplir objetivos a corto plazo, y que sabemos tendremos que arreglar en el futuro a un coste mayor, de la misma forma que un préstamo bancario nos puede sacar de un apuro hoy pero se traducirá en una cantidad mayor de dinero desembolsado a la larga.&lt;/p&gt;

&lt;p&gt;La diferencia entre Deuda Técnica y código chapucero, es que para este último hay pocas excusas. En mi artículo de &lt;a href=&quot;/2016/09/ventanas-rotas/&quot;&gt;Ventanas Rotas&lt;/a&gt; doy un repaso a varios ejemplos de esto.&lt;/p&gt;

&lt;h2 id=&quot;comunicación&quot;&gt;Comunicación&lt;/h2&gt;

&lt;p&gt;La comunicación con nuestros compañeros de trabajo, sean técnicos o no, es muy importante. Para conseguir una comunicación efectiva, la empatía es muy importante, y debemos adaptar nuestro discurso al oyente. Así, que por favor, nunca más le digáis a una persona de negocio algo como:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Necesitamos refactorizar la capa de persistencia, porque existen problemas de latencia causados por Hibernate. Además, nuestro pool de threads no está correctamente dimensionado&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Supongo que sabéis a lo que me refiero. Es necesario además distinguir las diferentes prioridades dentro de cada perfil con el que tenemos que tratar, y buscar un balance entre todas esas prioridades para encontrar una solución de consenso.&lt;/p&gt;

&lt;h2 id=&quot;arrancar-un-proyecto&quot;&gt;Arrancar un proyecto&lt;/h2&gt;

&lt;p&gt;El capítulo sobre arrancar un proyecto desde cero es quizás uno de los mejores del libro, y trata los diferentes desafíos que nos encontraremos a la hora de iniciar un “greenfield project”:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Comprender el problema: aquí los “stakeholders” son fundamentales, y el mayor problema que nos vamos a encontrar es que muchas veces no saben exactamente lo que quieren.&lt;/li&gt;
  &lt;li&gt;Analizar el nuevo rol de nuestro sistema dentro de la arquitectura global de nuestra empresa: las integraciones más sencillas pueden complicarse sobremanera, y hablo desde mi experiencia personal (una vez nos llevó un mes completo implementar un proceso de login para un aplicación nueva de una empresa financiera, debido a restricciones de seguridad).&lt;/li&gt;
  &lt;li&gt;Elegir el stack tecnológico, cosa que puede resultar más complicada de lo que parece, ya que la decisión está condicionada por el conocimiento dentro del equipo, preferencias históricas en nuestra empresa, nivel de familiarización dentro del equipo de operaciones, etc.&lt;/li&gt;
  &lt;li&gt;Esbozar una arquitectura a alto nivel del nuevo sistema.&lt;/li&gt;
  &lt;li&gt;Crear una versión mínima de la aplicación y desplegarla, lo que el libro &lt;a href=&quot;https://www.amazon.co.uk/s/ref=nb_sb_ss_i_1_14&quot;&gt;GOOS&lt;/a&gt; define como “Walking Skeleton”. En mi opinión, este paso es importantísimo, y hay que intentar tocar el mayor número posible de factores que puedan afectar a nuestra aplicación (Continuous Integration pipeline, third parties, librerías, persistencia, etc).&lt;/li&gt;
  &lt;li&gt;Iniciar el desarrollo de las historias de usuario.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Personalmente añadiría la escritura de una versión inicial del fichero README, que no solo sirva de guía para los nuevos desarrolladores que se incorporen al sistema, también como punto de referencia para que nadie pierda de vista la importancia de mantener un fichero README en condiciones. &lt;a href=&quot;https://jesuslc.com/2016/07/12/como-escribir-un-readme-que-mole/&quot;&gt;Jesús L.C. escribió de esto&lt;/a&gt; hace poco.&lt;/p&gt;

&lt;h2 id=&quot;escribir&quot;&gt;Escribir&lt;/h2&gt;

&lt;p&gt;Escribir de forma adecuada es imprescindible para avanzar en nuestra carrera, ya que se trata de una habilidad que deberemos utilizar en correos electrónicos, ficheros README, documentación, etc. Hay una sección muy interesante sobre cómo escribir emails de la forma más efectiva posible. En pocas palabras, viene a decir que la gente no suele leer los emails completos (¿os sorprende?), así que no pidáis o preguntéis más de una cosa por mensaje, y tratad de ofrecer alternativas (“¿prefieres la opción A o la opción B?”) para que el lector tenga que pararse a pensar el menor tiempo posible. En mi TODO list tengo la escritura de emails como tema pendiente, y volveré a ello en algún momento.&lt;/p&gt;

&lt;h2 id=&quot;entrevistar&quot;&gt;Entrevistar&lt;/h2&gt;

&lt;p&gt;Entrevistar a candidatos puede llegar a ser una parte muy importante en nuestro día a día. El libro describe una forma muy definida para realizar un proceso de selección (muy similar al estándar que se utiliza en muchas empresa de Londres, &lt;a href=&quot;/2015/04/trabajo-londres/&quot;&gt;y que describí aquí&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Personalmente, añado que entrevistar candidatos es de las labores más complicadas que nos pueden asignar. La demanda en nuestro sector es altísima, y encontrar gente muy buena se convierte en una empresa increíblemente dura. Los mayores dilemas que me he encontrado ocurrieron cuando no tenía claro si la persona era apta o no para el puesto. Para descargar de responsabilidad a los entrevistadores el libro recomienda intentar involucrar a varias personas en el proceso, de forma que todas deben estar de acuerdo en la decisión final. Esto se traduce en que existe “derecho de veto”, lo cual puede ser también una carga si tú eres la única persona vetando al candidato :).&lt;/p&gt;

&lt;h2 id=&quot;productividad&quot;&gt;Productividad&lt;/h2&gt;

&lt;p&gt;En este capítulo se describe un proceso para gestionar las interrupciones, tan presentes en los trabajos de oficina, de una manera efectiva. Recomienda no consultar el correo electrónico impulsivamente, sino hacerlo en momentos previamente decididos, y que encajen bien en el flujo de la metodología TDD, como por ejemplo cuando acabamos de refactorizar una nueva funcionalidad, o acabamos de definir un test fallido.&lt;/p&gt;

&lt;h2 id=&quot;liderar-equipos&quot;&gt;Liderar equipos&lt;/h2&gt;

&lt;p&gt;Este capítulo es el más extenso de todos, y diría que peca un poco de no profundizar demasiado en determinados aspectos de esta labor tan compleja. Se comentan temas como:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Estructura inicial del equipo: cuando todo es caos, y el mejor enfoque es constituir un equipo pequeño (dos desarrolladores, por ejemplo), y que vaya creciendo según se gane tracción.&lt;/li&gt;
  &lt;li&gt;Afrontar el aspecto más problemático dentro del rol de Team Leader, que no es otro que la comunicación de estimaciones a la gente de negocio. En mi opinión, una de las mejores formas (y más divertidas) de aprender como tratar este tema es &lt;a href=&quot;https://skillsmatter.com/skillscasts/8557-estimation-what-when-why-by-robert-martin&quot;&gt;viendo esta presentación de Uncle Bob&lt;/a&gt; (en la que por cierto, podéis buscarme entre el público :D).&lt;/li&gt;
  &lt;li&gt;Marcar un ritmo en el proyecto, mediante breves reuniones semanales donde el equipo presenta su trabajo (en mi empresa esto lo conocemos como &lt;a href=&quot;https://content.pivotal.io/blog/running-an-ipm&quot;&gt;IPM&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;Realizar revisiones de código efectivas, de manera que resulte productiva para todos los desarrolladores y no genere rencillas. El principal consejo aquí es comentar el código directamente sin mencionar o dirigirse directamente a la persona que lo escribió (por ejemplo: “este código podría ser más claro si extrayéramos este bloque a un método independiente” vs “este método te ha quedado demasiado largo”).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;producción&quot;&gt;Producción&lt;/h2&gt;

&lt;p&gt;Finalmente tendremos nuestro sistema en producción, y en este punto es muy importante que nuestra aplicación genere información de manera adecuada para gestionar de manera correcta incidencias, buscar puntos de mejora, etc. Se describe el proceso para generar logs, alertas y estadísticas, y se hace hincapié en la importancia de escribir código tolerante a fallos.&lt;/p&gt;

&lt;h2 id=&quot;conclusiones&quot;&gt;Conclusiones&lt;/h2&gt;

&lt;p&gt;No dejéis pasar este libro, es un compendio excelente de buenas prácticas a seguir para convertirnos en buenos programadores, y además incluye una lista de lectura con libros y artículos que sirven de complemento perfecto para continuar aprendiendo. Me extraña bastante no verlo más a menudo en recopilaciones de libros que todo desarrollador debería leer, y espero que el tiempo le haga justicia (se publicó inicialmente en 2014).&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Cómo funciona Git (parte 2)</title>
   <link href="http://www.raulavila.com/2017/02/como-funciona-git-2/"/>
   <updated>2017-02-11T00:00:00+00:00</updated>
   <id>http://www.raulavila.com/2017/02/como-funciona-git-2</id>
   <content type="html">&lt;p&gt;En &lt;a href=&quot;/2017/01/como-funciona-git-1/&quot;&gt;el primer post de esta serie&lt;/a&gt; comenzamos a destripar el funcionamiento interno de Git, revisando los diferentes tipos de datos que Git soporta internamente. Si no lo habéis leído &lt;a href=&quot;/2017/01/como-funciona-git-1/&quot;&gt;deberíais empezar por ahí&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dejamos nuestro repositorio en el siguiente estado:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.
└── hello.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Es decir, un directorio con un fichero &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.txt&lt;/code&gt;, fichero que contiene el texto “Hello World”. Tras hacer nuestro primer commit y añadir un tag, nos quedó la siguiente estructura interna:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-first-commit-tag.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Seguiremos trabajando desde aquí.&lt;/p&gt;

&lt;!--break--&gt;

&lt;h2 id=&quot;segundo-commit&quot;&gt;Segundo commit&lt;/h2&gt;

&lt;p&gt;Vamos a añadir una nueva carpeta &lt;code class=&quot;highlighter-rouge&quot;&gt;greetings&lt;/code&gt;, que contendrá un fichero, &lt;code class=&quot;highlighter-rouge&quot;&gt;hello2.txt&lt;/code&gt; con el mismo texto “Hello World”:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ mkdir greetings

$ cd greetings

$ cp ../hello.txt .

$ mv hello.txt hello2.txt

$ cd ..

$ tree
.
├── greetings
│   └── hello2.txt
└── hello.txt

1 directory, 2 files

$ git add .

$ git commit -m &quot;Second commit&quot;
[master 284c288] Second commit
 1 file changed, 1 insertion(+)
 create mode 100644 greetings/hello2.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Tras estas operaciones, nuestra carpeta &lt;code class=&quot;highlighter-rouge&quot;&gt;.git/objects&lt;/code&gt; contiene ahora 7 objetos:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;├── objects
│   ├── 04
│   │   └── 50100369ff9e0b980dfc6ae42aaeb1de6890f6
│   ├── 28
│   │   └── 4c288acedfc52626386bbf134465f073cf2990
│   ├── 4a
│   │   └── f5100442a48dd4b8a53e4cb05b848d0336d8d7
│   ├── 55
│   │   └── 7db03de997c86a4a028e1ebd3a1ceb225be238
│   ├── 97
│   │   └── b49d4c943e3715fe30f141cc6f27a8548cee0e
│   ├── d1
│   │   └── ee121d5fe96b891ac0cc695498f31c0a4a7664
│   ├── ee
│   │   └── 6b307ad7ed6204ec4331aa38c04ea73b684287
│   ├── info
│   └── pack&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Comparando con la versión anterior, tenemos tres nuevos objetos, vamos a revisarlos de forma individual, y comprobar cómo ha quedado la estructura en forma de árbol.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;284c28&lt;/code&gt;, es el objeto que contiene la información del segundo commit:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git cat-file -t 284c28
commit

$ git cat-file -p 284c28
tree ee6b307ad7ed6204ec4331aa38c04ea73b684287
parent d1ee121d5fe96b891ac0cc695498f31c0a4a7664
author RaulAvila &amp;lt;xxxxx@gmail.com&amp;gt; 1486816422 +0000
committer RaulAvila &amp;lt;xxxxx@gmail.com&amp;gt; 1486816422 +0000

Second commit&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Este commit se diferencia del primero en que tiene un parent, &lt;code class=&quot;highlighter-rouge&quot;&gt;d1ee12&lt;/code&gt;, que no es más que el primer commit. Esta es la forma en que Git controla el histórico enlazando commit sucesivos. También vemos que nuestro commit referencia a un nuevo tree, &lt;code class=&quot;highlighter-rouge&quot;&gt;ee6b30&lt;/code&gt;, el segundo objeto añadido con este commit:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git cat-file -t ee6b30
tree

$ git cat-file -p ee6b30
040000 tree 4af5100442a48dd4b8a53e4cb05b848d0336d8d7	greetings
100644 blob 557db03de997c86a4a028e1ebd3a1ceb225be238	hello.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Este objeto tree es el nuevo root de nuestro proyecto. Vemos que este root ahora contiene el fichero &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.txt&lt;/code&gt;, que no ha cambiado respecto al primer commit, por lo que sigue estando contenido en el objecto &lt;code class=&quot;highlighter-rouge&quot;&gt;557db0&lt;/code&gt;, y la nueva carpeta, que está almacenada en git como un nuevo objeto tree, &lt;code class=&quot;highlighter-rouge&quot;&gt;4af510&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git cat-file -t 4af510
tree

$ git cat-file -p 4af510
100644 blob 557db03de997c86a4a028e1ebd3a1ceb225be238	hello2.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;El contenido de la carpeta es un puntero al contenido (blob) del nuevo fichero, de nombre &lt;code class=&quot;highlighter-rouge&quot;&gt;hello2.txt&lt;/code&gt;. ¿Notáis algo llamativo? En efecto, el hash al que apunta este tree es también &lt;code class=&quot;highlighter-rouge&quot;&gt;557db0&lt;/code&gt;, esto es así porque ambos ficheros contienen la misma información, de forma que el hash calculado es idéntico.&lt;/p&gt;

&lt;p&gt;Con todo esto, veamos cómo queda nuestro árbol de objetos:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-second-commit.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Este va a ser el diagrama más complicado que veremos en la serie, y espero que más o menos haya quedado claro. Git intenta reutilizar toda la información que sea posible al añadir nuevos commits, y así, el blob “Hello World” es apuntado desde tres lugares diferentes (el fichero del primer commit, el mismo fichero del segundo, y el nuevo fichero del segundo). De esta forma se minimiza la cantidad de datos creados por cada cambio. Además, las carpetas &lt;code class=&quot;highlighter-rouge&quot;&gt;info&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;pack&lt;/code&gt; se utilizan en procesos de compresión que no cubriremos aquí (para empezar, porque no los conozco todavía :)).&lt;/p&gt;

&lt;p&gt;A continuación veremos una de las funcionalidades más potentes de Git, y os asombraréis de lo sencilla que es su implementación.&lt;/p&gt;

&lt;h2 id=&quot;ramas&quot;&gt;Ramas&lt;/h2&gt;

&lt;p&gt;Para comprender bien el funcionamiento de las ramas (branches) en Git, vamos a simplificar el diagrama de la estructura que hemos ido creando, y nos quedaremos únicamente con los commits:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-commit-history-1.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Todos sabemos que cuando iniciamos un proyecto Git, este nos crea con nuestro primer commit una única rama de nombre &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;. Internamente, una rama es algo tan tonto como un pequeño ficherito que apunta a un commit, ni más ni menos, es decir, un alias:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ cat .git/refs/heads/master
284c288acedfc52626386bbf134465f073cf2990&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Como véis, el contenido de este fichero es el hash del último commit que hemos realizado:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-master.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La gran diferencia entre tags y ramas es que los tags son inmutables, mientras que las ramas están “vivas”, avanzando con cada commit añadido a la historia.&lt;/p&gt;

&lt;p&gt;Vamos a crear una nueva rama apuntando al mismo commit:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git branch develop

$ cat .git/refs/heads/develop
284c288acedfc52626386bbf134465f073cf2990&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Sin demasiadas sorpresas, la nueva rama apunta al commit en que nos encontramos, coincidendo con &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;, es decir:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-master-develop.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La pregunta aquí es qué rama será la que avanzará si añadimos un nuevo commit, veámoslo en vivo:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ echo &quot;Goodbye&quot; &amp;gt; goodbye.txt

$ git add .

$ git commit -m &quot;Third commit&quot;
[master aa90e47] Third commit
 1 file changed, 1 insertion(+)
 create mode 100644 goodbye.txt

$ cat .git/refs/heads/master
aa90e471ababde242281c833fffea255f69dd28a

$ cat .git/refs/heads/develop
284c288acedfc52626386bbf134465f073cf2990

$ git branch
  develop
* master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;En efecto, seguimos en &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;, porque &lt;code class=&quot;highlighter-rouge&quot;&gt;git branch&lt;/code&gt; tan solo crea una rama en el actual commit sin ponerla como rama activa. Para conseguir esto deberíamos hacer:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git checkout develop
Switched to branch 'develop'

$ git branch
* develop
  master&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ahora sí, nuestra rama activa es develop, y si añadimos un nuevo commit no será asociado a master hasta que realicemos un merge o un rebase (volveremos sobre esto en el siguiente post). Como alternativa, podríamos crear una nueva rama y movernos a ella en un paso con &lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b rama&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;¿Cómo almacena Git la información de la rama activa? Pues muy sencillo, en el fichero &lt;code class=&quot;highlighter-rouge&quot;&gt;.git/HEAD&lt;/code&gt;, que en realidad no es más que un fichero de texto apuntando al lugar en que nos encontramos dentro del histórico (es decir, un puntero a un puntero). De hecho este fichero no tiene por qué apuntar a una rama, puede hacerlo a un commit determinado si hacemos un &lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout &amp;lt;hash&amp;gt;&lt;/code&gt;, lo que se conoce como “detached HEAD”. Veamos varios ejemplos de esto:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git branch
* develop
  master

$ cat .git/HEAD
ref: refs/heads/develop

$ git checkout master
Switched to branch 'master'

$ cat .git/HEAD
ref: refs/heads/master

$ git checkout aa90e47
Note: checking out 'aa90e47'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &amp;lt;new-branch-name&amp;gt;

HEAD is now at aa90e47... Third commit

$ cat .git/HEAD
aa90e471ababde242281c833fffea255f69dd28a

$ git checkout develop
Previous HEAD position was aa90e47... Third commit
Switched to branch 'develop'&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Tras este mareo, este es la instantánea de nuestro histórico:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-head.jpg&quot; alt=&quot;Git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Lo dejamos aquí por hoy. &lt;a href=&quot;/2017/03/como-funciona-git-3/&quot;&gt;En el último post de la serie&lt;/a&gt; veremos cómo funcionan &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;, y finalizaremos con la sincronización con repositorios remotos.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>¿Volver?</title>
   <link href="http://www.raulavila.com/2017/01/volver/"/>
   <updated>2017-01-29T00:00:00+00:00</updated>
   <id>http://www.raulavila.com/2017/01/volver</id>
   <content type="html">&lt;p&gt;Escribo este post inspirado por los correos dominicales de &lt;a href=&quot;http://us2.campaign-archive1.com/?u=374c664073e1a1fa3deca53b4&amp;amp;id=33d5cc4ff8&amp;amp;e=b93d18ec09&quot;&gt;David Bonilla&lt;/a&gt; y &lt;a href=&quot;http://us2.campaign-archive1.com/?u=6a0dd93f8651955858ab8633f&amp;amp;id=a9ff5e4957&amp;amp;e=96ff600f8b&quot;&gt;Jerónimo Palacios&lt;/a&gt;, ambos titulados igual: “Volver”. Jerónimo acaba de trasladar su “base de operaciones” a Granada, su ciudad de origen si no recuerdo mal, aunque seguirá trabajando en toda Europa. Y Bonilla analiza la emigración masiva que se dió en España a primeros de la década, cómo muchos informáticos tomaron la decisión de marcharse aún teniendo trabajo de sobra en nuestro país, y si se dan las condiciones para que vuelvan.&lt;/p&gt;

&lt;!--break--&gt;

&lt;p&gt;Este tema me toca muy cerca porque, como bien sabréis si me seguís con algo de regularidad, vivo en Londres, &lt;a href=&quot;/2015/04/trabajo-londres/&quot;&gt;ciudad a la que me mudé&lt;/a&gt; en Abril de 2014. Yo era uno de esos informáticos que comenta Bonilla estaban con trabajo, de hecho en mi último año trabajé en más de una empresa. Aún así decidí hacer las maletas buscando nuevos desafíos.&lt;/p&gt;

&lt;h2 id=&quot;españa-vs-uk&quot;&gt;España vs UK&lt;/h2&gt;

&lt;p&gt;Porque de eso se trató en realidad, de buscar desafíos. Con 33 años no me apetecía nada quedarme estancado en el rol “Desarrollador Senior” según se entiende en la mayor parte de empresas españolas. Añado esto último porque precisamente una de las primeras cosas que aprendí en UK fue que el puesto de “Senior Developer” puede tener todo el recorrido que quieras sin restricciones de techo salarial o responsabilidades. De hecho, algo que al principió me impactó bastante fue comprobar como determinados puestos de “Project Manager” tenían un salario menor que el de los “Senior Developer” en su mismo proyecto, siendo esto así porque los roles definen responsabilidades y no jerarquías.&lt;/p&gt;

&lt;p&gt;Es decir, aunque es inevitable que existan las escaleras corporativas / salariales dentro de una empresa, no existen tanto a nivel de proyecto / equipo, cosa que convierte los puestos de trabajo en algo mucho más estimulante.&lt;/p&gt;

&lt;p&gt;Otra cosa interesante que he encontrado es respeto. En ningún caso he escuchado la famosa frase “al menos alégrate de tener trabajo”, que tantas veces oí en España cuando venían mal dadas. Aquí queda claro que en la relación empresa - empleado existe un beneficio mutuo que interesa mantener, y donde la formación constante es también muy importante. Así por ejemplo, nunca me he tenido que ver suplicando a mi responsable que me deje asistir a una conferencia o evento, de hecho en mi actual empresa tenemos un presupuesto anual exclusivo para este tipo de cosas.&lt;/p&gt;

&lt;h3 id=&quot;abanico-de-opciones--emprender&quot;&gt;Abanico de opciones / Emprender&lt;/h3&gt;

&lt;p&gt;Desde que descubrí lo fácil que es emprender en UK, siempre he dicho que el verdadero drama de España es la dificultad para el emprendimiento. Si quisiera montar una empresa aquí mañana por la mañana la tendría funcionando, y con posibilidad de facturar de inmediato antes incluso de soltar un penique. Supongo que esto no os resulta nuevo, a España llegan mucho este tipo de comparativas, pero cuando lo vives desde dentro realmente impresiona y da que pensar. Mi mujer, por ejemplo, está trabajando de freelance, y en su declaración de este año le salieron 330 libras a pagar, sin ningún otro gasto adicional. A modo de anécdota, una vez conté en un evento el desembolso que había que hacer en España para emprender, y se empezaron todos a reir porque pensaban que estaba de coña. Cuando me puse serio y dije que era verdad, fliparon bastante.&lt;/p&gt;

&lt;p&gt;Si quisiera ofrecer mis servicios como autónomo a empresas de informática, no tendría más que enviar unos pocos currículums, y en poco tiempo habría encontrado una empresa que me pagaría entre 450 y 550 libras al día. &lt;a href=&quot;http://www.itjobswatch.co.uk/contracts/london/senior%20developer.do&quot;&gt;Y no me estoy sacando estos números de la manga&lt;/a&gt;. El contracting no es algo que me llame especialmente, me gusta la estabilidad de trabajar en un sitio que me guste, pero saber que las posibilidades están ahí da mucha tranquilidad.&lt;/p&gt;

&lt;p&gt;Por último, y para puestos de trabajo con contrato permanente, aquí puedes encontrar empresas de todo tipo, por lo que si quieres probar un sector o tipo de empresa en concreto podrás hacerlo en algún momento, es cuestión de paciencia.&lt;/p&gt;

&lt;h2 id=&quot;brexit&quot;&gt;Brexit&lt;/h2&gt;

&lt;p&gt;Puede que más de uno esté pensando si mi opinión ha cambiado tras el voto del Brexit. Bien, mi respuesta es contundente: no, todo lo contrario. Tras el Brexit mi empresa, Pivotal, se ha volcado para que los inmigrantes &lt;a href=&quot;https://twitter.com/pivotal/status/798227756156932096&quot;&gt;nos sintamos totalmente acogidos&lt;/a&gt;, en Londres he notado que el sentir general hacia nosotros es de agradecimiento, y la ciudad está intentando &lt;a href=&quot;https://www.london.gov.uk/about-us/mayor-london/londonisopen&quot;&gt;abrirse más que nunca&lt;/a&gt;. Así que, personalmente, el Brexit no me ha hecho replantearme si quedarme aquí o volver, aunque está por ver cómo responderá la economía en caso de ruptura total con la UE.&lt;/p&gt;

&lt;p&gt;Quizás si viviera en otras ciudades más pequeñas habría notado una diferencia, no lo sé. Pero sí quiero añadir algo, a mí personalmente me repatean el racismo y xenofobia en cualquier dirección, y no creo que en España se pueda sacar demasiado pecho en cuanto a la falta de racismo. Empecemos mirando nuestro propio ombligo, y este es un mensaje para los medios de comunicación españoles, que tanto alarmismo están levantando últimamente hablando del Reino Unido.&lt;/p&gt;

&lt;h2 id=&quot;volver&quot;&gt;¿Volver?&lt;/h2&gt;

&lt;p&gt;Me consta que en los últimos años nuestro sector está mejorando mucho en España. Empezando por las comunidades, que dan cabida a eventos como el &lt;a href=&quot;/2016/11/codemotion-2016/&quot;&gt;Codemotion&lt;/a&gt; o montones de meetups, sobre todo en Madrid y Barcelona, pasando por empresas españolas con ganas de cambiar las cosas (&lt;a href=&quot;http://www.codesai.com/&quot;&gt;Codesai&lt;/a&gt;, &lt;a href=&quot;https://www.logtrust.com/en/&quot;&gt;LogTrust&lt;/a&gt;…), y terminando por importantes empresas internacionales que han decidido abrir oficina (&lt;a href=&quot;https://codurance.com/&quot;&gt;Codurance&lt;/a&gt; y &lt;a href=&quot;https://www.thoughtworks.com/&quot;&gt;Thoughtworks&lt;/a&gt; a la cabeza).&lt;/p&gt;

&lt;p&gt;David Bonilla ha metido el dedo en la llaga hablando de los lazos familiares. Tener a toda la familia y amigos lejos se hace duro en muchos momentos, yo aún no tengo hijos, pero sé lo complicado que sería dar ese paso, por ejemplo. Tampoco he tenido mala suerte, de momento, en cuestiones de salud. Todos estos factores pueden suponer un buen empujón para tomar la decisión de volver.&lt;/p&gt;

&lt;p&gt;Así que, quien sabe, quizás vuelva algún día, aunque de hacerlo, me gustaría poder hacer valer toda la experiencia que he ido adquiriendo aquí, principalmente a nivel de idioma. &lt;a href=&quot;/2016/12/aprender-ingles/&quot;&gt;Aprender un segundo lenguaje en condiciones&lt;/a&gt; está siendo muy complicado, y no quiero pensar que no pudiera seguir sacándole partido en un futuro. También me gustaría que se pudieran dar la mayor parte de las circunstancias que he comentado en este post, aunque algunas de ellas &lt;a href=&quot;http://www.silicon.es/los-emprendedores-lo-tienen-facil-en-espana-infografia-54433&quot;&gt;me parecen una utopía&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Cómo funciona Git (parte 1)</title>
   <link href="http://www.raulavila.com/2017/01/como-funciona-git-1/"/>
   <updated>2017-01-22T00:00:00+00:00</updated>
   <id>http://www.raulavila.com/2017/01/como-funciona-git-1</id>
   <content type="html">&lt;p&gt;El sábado pasado estuve en un workshop sobre &lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt; impartido por el gran &lt;a href=&quot;https://twitter.com/theNeomatrix369&quot;&gt;Mani&lt;/a&gt; en la &lt;a href=&quot;https://twitter.com/theNeomatrix369&quot;&gt;London Software Craftmanship Community&lt;/a&gt;. Me sirvió para consolidar de manera más o menos definitiva los conocimientos sobre esta herramienta que he ido adquiriendo con la práctica durante casi tres años ya.&lt;/p&gt;

&lt;p&gt;Al volver a casa, me picó el gusanillo en relación al funcionamiento interno de Git, así que he estado investigando un poco, y plasmaré lo aprendido en esta serie de posts. Personalmente, he descubierto que conocer este funcionamiento interno es muy útil para tener menos miedo a la magia de Git, porque, en el fondo, los principios más importantes no tienen demasiado misterio. Asumo que, si estás leyendo esto, es porque posees un conocimiento de Git “medio”, en caso contrario os recomiendo empezar &lt;a href=&quot;http://gitimmersion.com/&quot;&gt;por aquí&lt;/a&gt; y volver después a este post.&lt;/p&gt;

&lt;!--break--&gt;

&lt;h2 id=&quot;qué-es-git-estructura-básica&quot;&gt;Qué es Git. Estructura básica&lt;/h2&gt;

&lt;p&gt;Git es una herramienta de control de versiones distribuida, pero en última instancia no es más que un gestor de contenido, y en este post entenderéis por qué.&lt;/p&gt;

&lt;p&gt;El núcleo de Git no es ni más ni menos que un mapa clave-valor de toda la vida, donde las claves son valores hash generados mediante el &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;algoritmo SHA1&lt;/a&gt;, y los valores pueden ser varias cosas. En este post nos centraremos en los diferentes tipos de valor que Git puede almacenar.&lt;/p&gt;

&lt;p&gt;Supongo que os será familiar, pero una clave hash SHA1 es algo así:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cf23df2207d99a74fbe169e3eba035e633b65d94&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Es decir, una serie de 40 caracteres, que Git generará a partir del contenido que almacenemos en el valor correspondiente. Esto significa que, a mismo valor, misma clave hash generada. Para hacer la prueba sólo tenéis que utilizar uno de los conocidos como “plumbing commands” en Git, &lt;code class=&quot;highlighter-rouge&quot;&gt;hash-object&lt;/code&gt;, de la siguiente forma:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;echo Hello World | git hash-object --stdin&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Comando que generará el valor &lt;code class=&quot;highlighter-rouge&quot;&gt;557db03de997c86a4a028e1ebd3a1ceb225be238&lt;/code&gt;, desde cualquier máquina, y por supuesto, de forma idempotente.&lt;/p&gt;

&lt;p&gt;El comando &lt;code class=&quot;highlighter-rouge&quot;&gt;hash-object&lt;/code&gt; puede invocarse sin necesidad de estar en un repositorio de Git y funcionará sin problemas. Para seguir clarificando conceptos, sin embargo, vamos a crear un repositorio de Git, para trabajar desde allí (lo que conseguimos con &lt;code class=&quot;highlighter-rouge&quot;&gt;git init&lt;/code&gt; en cualquier carpeta, preferentemente vacía).&lt;/p&gt;

&lt;p&gt;Más o menos todos sabemos que inicializar un directorio como repositorio de Git crea una carpeta &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt; con varias cosas, aquí tenemos una captura de una versión recién creada:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.git
├── HEAD
├── branches
├── config
├── description
├── hooks
│   ├── applypatch-msg.sample
│   ├── commit-msg.sample
│   ├── post-update.sample
│   ├── pre-applypatch.sample
│   ├── pre-commit.sample
│   ├── pre-push.sample
│   ├── pre-rebase.sample
│   ├── pre-receive.sample
│   ├── prepare-commit-msg.sample
│   └── update.sample
├── info
│   └── exclude
├── objects
│   ├── info
│   └── pack
└── refs
    ├── heads
    └── tags&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Muchas de ellas las iremos desgranando en esta serie. La subcarpeta más importante, y la que contiene el mapa clave-valor que he mencionado más arriba, es &lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt;. Vemos que, de momento, &lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt; está vacía, tan solo tiene dos sucarpetas, &lt;code class=&quot;highlighter-rouge&quot;&gt;info&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;pack&lt;/code&gt;, también vacías, y que vamos a ignorar por ahora.&lt;/p&gt;

&lt;h2 id=&quot;guardando-objetos&quot;&gt;Guardando objetos&lt;/h2&gt;

&lt;p&gt;Vamos a utilizar de nuevo &lt;code class=&quot;highlighter-rouge&quot;&gt;hash-object&lt;/code&gt; para almacenar una entrada con el valor “Hello World” en &lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt;. Esto lo podemos conseguir de la siguiente manera:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ echo Hello World | git hash-object --stdin -w
557db03de997c86a4a028e1ebd3a1ceb225be238&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Aunque la salida del comando es la misma que conseguimos al lanzarlo sin la opción &lt;code class=&quot;highlighter-rouge&quot;&gt;-w&lt;/code&gt;, ha ocurrido algo interesante. Analicemos de nuevo el contenido de &lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;├── objects
│   ├── 55
│   │   └── 7db03de997c86a4a028e1ebd3a1ceb225be238
│   ├── info
│   └── pack&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Vemos que ahora tenemos una carpeta, &lt;code class=&quot;highlighter-rouge&quot;&gt;55&lt;/code&gt;, con un fichero, &lt;code class=&quot;highlighter-rouge&quot;&gt;7db03de997c86a4a028e1ebd3a1ceb225be238&lt;/code&gt;. Es decir, Git ha tomado los dos primeros caracteres de la clave hash generada a partir del valor “Hello World”, ha creado una carpeta, y con el resto de la clave ha creado un fichero. El contenido de este fichero no se puede inspeccionar con un editor de texto, pero sí existe un comando de Git que nos permite visualizar su contenido fácilmente, &lt;code class=&quot;highlighter-rouge&quot;&gt;cat-file&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git cat-file -p 557db03de997c86a4a028e1ebd3a1ceb225be238
Hello World

$ git cat-file -p 557db03
Hello World&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;He repetido el comando dos veces, la segunda de manera simplificada, para demostrar que, si nuestro repositorio Git no tiene dos claves que empiecen por &lt;code class=&quot;highlighter-rouge&quot;&gt;557db03&lt;/code&gt; es posible trabajar con las claves simplificadas igualmente. Podemos bajar hasta a cuatro caracteres si queremos, pero lo normal es simplificar a 6 o 7, cifra que prácticamente elimina la posibilidad de tener duplicados en un mismo repositorio.&lt;/p&gt;

&lt;p&gt;El comando &lt;code class=&quot;highlighter-rouge&quot;&gt;cat-file&lt;/code&gt; también permite interrogar por el tipo del valor, veamos qué obtenemos:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git cat-file -t 557db03
blob&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;En efecto, el tipo de nuestro valor es &lt;strong&gt;blob&lt;/strong&gt;, que viene a ser un array de bytes sin más, y es el tipo que se utiliza para almacenar los ficheros que todos subimos a nuestro control de versiones, sean binarios o código fuente. Es uno de los cuatro tipos que Git puede almacenar en su repositorio. Sí, habéis leído bien, Git sólo maneja cuatro tipos de datos.&lt;/p&gt;

&lt;p&gt;Vamos a ir dibujando un diagrama de nuestro repositorio sobre la marcha. De momento, lo que tenemos es:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-blob.jpg&quot; alt=&quot;Git Blob&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;primer-commit&quot;&gt;Primer commit&lt;/h2&gt;

&lt;p&gt;Aunque hemos utilizado un “plumbing command” para guardar algo en el repositorio, esta no es para nada la forma habitual de utilizar Git. En el 100% de los casos, crearemos un fichero con algún contenido, así que vamos a ello:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ echo Hello World &amp;gt; hello.txt

$ git add .

$ git commit -m &quot;First commit&quot;
[master (root-commit) d1ee121] First commit
 1 file changed, 1 insertion(+)
 create mode 100644 hello.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Como ya he comentado anteriormente, se presupone cierto conocimiento de la herramienta, por lo que no entraré en detalles de lo que estoy haciendo en cada paso. Tan sólo añadir que, nuestra carpeta &lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt; ha permanecido inmutable hasta el último commando, es decir, hasta el momento en que hemos hecho commit, donde ha quedado así:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;├── objects
│   ├── 55
│   │   └── 7db03de997c86a4a028e1ebd3a1ceb225be238
│   ├── 97
│   │   └── b49d4c943e3715fe30f141cc6f27a8548cee0e
│   ├── d1
│   │   └── ee121d5fe96b891ac0cc695498f31c0a4a7664
│   ├── info
│   └── pack&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Es decir, se han añadido cuatro entradas nuevas al mapa clave-valor. Vamos a inspeccionar cada una de ellas.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;557db03&lt;/code&gt; sigue siendo la entrada que añadimos manualmente, es decir, el blob “Hello World”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Vamos a utilizar el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; para conocer la clave hash que se ha asociado al commit:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git log -1
commit d1ee121d5fe96b891ac0cc695498f31c0a4a7664
Author: RaulAvila &amp;lt;xxxxxx@gmail.com&amp;gt;
Date:   Sun Jan 22 18:50:55 2017 +0000

    First commit&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;La clave hash simplificada del commit es &lt;code class=&quot;highlighter-rouge&quot;&gt;d1ee121&lt;/code&gt;. Veamos qué obtenemos con &lt;code class=&quot;highlighter-rouge&quot;&gt;cat-file&lt;/code&gt;, de la misma forma en que hicimos con el blob:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git cat-file -t d1ee121
commit

$ git cat-file -p d1ee121
tree 97b49d4c943e3715fe30f141cc6f27a8548cee0e
author RaulAvila &amp;lt;xxxxxx@gmail.com&amp;gt; 1485111055 +0000
committer RaulAvila &amp;lt;xxxxxx@gmail.com&amp;gt; 1485111055 +0000

First commit&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Es decir, el tipo del valor asociado a &lt;code class=&quot;highlighter-rouge&quot;&gt;d1ee121&lt;/code&gt; es &lt;strong&gt;commit&lt;/strong&gt;, por lo que acabamos de descubrir el segundo tipo de datos que puede almacenar Git. El contenido del fichero, además de la información que muestra el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt;, hace referencia a un “tree”, con un código hash, que “casualmente” también encontramos en la carpeta &lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;97b49d4&lt;/code&gt;. Así que vamos a inspeccionar este hash:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git cat-file -t 97b49d4
tree

$ git cat-file -p 97b49d4
100644 blob 557db03de997c86a4a028e1ebd3a1ceb225be238	hello.txt&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Acabamos de descubrir el tercer tipo de datos, &lt;strong&gt;tree&lt;/strong&gt;, que viene a ser el equivalente a una carpeta en una estructura de ficheros de toda la vida. De hecho si mostramos el contenido del valor de esta entrada tree, lo que tenemos es una lista de ficheros, donde la primera columna son permisos de acceso, la segunda el tipo del valor (que puede ser un blob u otro tree), la tercera la clave hash que lo identifica, y la segunda el nombre del fichero. Muy parecido a la salida de &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; en Unix, ¿verdad? Seguro que ya os habéis dado cuenta de la naturaleza recursiva de esta estructura, puesto que un tree puede contener otros trees a varios niveles, además de ficheros “normales”, o blobs. A modo de ejemplo, esta podría ser una salida perfectamente válida del comando &lt;code class=&quot;highlighter-rouge&quot;&gt;cat-file -p&lt;/code&gt; sobre un valor tree:&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;100644 blob 557db03de997c86a4a028e1ebd3a1ceb225be238     hello.txt
040000 tree f27fede2220bcd326aee3e86ddfd4ebd0fe58cb9     src&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Es decir, un fichero y otra carpeta, que a su vez puede contener más ficheros.&lt;/p&gt;

&lt;p&gt;En este punto ya hemos visto que nuestra carpeta &lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt; tiene tres entradas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;557db03&lt;/code&gt;, el valor “Hello World” que almacenamos de forma manual antes de crear nuestro primer fichero + commit&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;d1ee121&lt;/code&gt; contiene toda la información de nuestro primer commit, con un tree directamente asociado al commit, a modo de root&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;97b49d4&lt;/code&gt; es el mencionado tree, y contiene un fichero de nombre “hello.txt”, que está asociado al hash &lt;code class=&quot;highlighter-rouge&quot;&gt;557db03&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;¡Un momento! ¿Habéis notado algo? El valor hash asociado al fichero “hello.txt” es exactamente el mismo que nosotros añadimos manualmente antes de hacer un commit. En efecto, Git ha detectado que el contenido del fichero es el mismo que el que ya existe en esa entrada del repositorio (más que nada porque el valor hash generado es idéntico), ¡y la ha reutilizado! De hecho, la entrada &lt;code class=&quot;highlighter-rouge&quot;&gt;557db03&lt;/code&gt; contiene sólo el blob “Hello World”, sin ninguna información del nombre del fichero que lo contiene. Esta información es propiedad del objeto tree que referencie a dicho blob.&lt;/p&gt;

&lt;p&gt;Si completamos el diagrama, asociando los diferentes valores, nos quedaría algo así:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-first-commit.jpg&quot; alt=&quot;Git Blob&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tags&quot;&gt;Tags&lt;/h2&gt;

&lt;p&gt;Comenté anteriormente que Git puede almacenar cuatro tipos de datos, pero de momento sólo hemos visto tres. El tipo que nos queda es más difícil de introducir de manera “casual”, y es &lt;strong&gt;tag&lt;/strong&gt;. Supongo que estaréis familiarizados con los tags de Git, para marcar un commit concreto que nos interesa. Vamos a hacerlo con este primer commit:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git tag -a first -m &quot;First Commit&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Tras hacer esto, los cambios dentro de nuestra carpeta &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt; se pueden ver aquí:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;├── objects
│   ├── 04
│   │   └── 50100369ff9e0b980dfc6ae42aaeb1de6890f6
│   ├── 55
│   │   └── 7db03de997c86a4a028e1ebd3a1ceb225be238
│   ├── 97
│   │   └── b49d4c943e3715fe30f141cc6f27a8548cee0e
│   ├── d1
│   │   └── ee121d5fe96b891ac0cc695498f31c0a4a7664
│   ├── info
│   └── pack
└── refs
    ├── heads
    │   └── master
    └── tags
        └── first&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Son los siguientes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tenemos un nuevo valor en &lt;code class=&quot;highlighter-rouge&quot;&gt;objects&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;0450100&lt;/code&gt;, una inspección con &lt;code class=&quot;highlighter-rouge&quot;&gt;cat-file&lt;/code&gt; nos da lo siguiente:&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git cat-file -t 0450100
tag

$ git cat-file -p 0450100
object d1ee121d5fe96b891ac0cc695498f31c0a4a7664
type commit
tag first
tagger RaulAvila &amp;lt;xxxxxx@gmail.com&amp;gt; 1485112874 +0000

First Commit&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Es decir, el valor es del tipo &lt;strong&gt;tag&lt;/strong&gt;, como hemos adelantado, y apunta al objeto &lt;code class=&quot;highlighter-rouge&quot;&gt;d1ee121&lt;/code&gt;, que no es más que el commit en el que estábamos cuando creamos el tag. Este valor también contiene la descripción que añadimos al tag cuando lo creamos.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;En la carpeta &lt;code class=&quot;highlighter-rouge&quot;&gt;.git/refs/tags&lt;/code&gt; tenemos un nuevo fichero, &lt;code class=&quot;highlighter-rouge&quot;&gt;first&lt;/code&gt;, que podemos inspeccionar con un editor de texto o el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ cat .git/refs/tags/first
0450100369ff9e0b980dfc6ae42aaeb1de6890f6&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Está claro que este fichero no es más que un alias que contiene una referencia al hash del tag creado, ni más ni menos.&lt;/p&gt;

&lt;p&gt;Con esto, actualicemos nuestro diagrama:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/pictures/git-internals/git-first-commit-tag.jpg&quot; alt=&quot;Git Blob&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Terminamos esta primera entrega sobre el funcionamiento interno de Git. &lt;a href=&quot;/2017/02/como-funciona-git-2/&quot;&gt;En la siguiente&lt;/a&gt; veremos cómo Git añade nuevos commits al histórico, revisaremos los tipos de datos durante el proceso, y veremos cómo se realiza la gestion de ramas.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>You fui un mal programador</title>
   <link href="http://www.raulavila.com/2017/01/yo-fui-un-mal-programador/"/>
   <updated>2017-01-09T00:00:00+00:00</updated>
   <id>http://www.raulavila.com/2017/01/you-fui-un-mal-programador</id>
   <content type="html">&lt;p&gt;Yo fui un mal programador. Cuando terminé la carrera, como primero de promoción, pensé que ya había cumplido mi parte, y que las empresas deberían reconocer mi valía de inmediato, por lo que cuando nadie valoró ese detalle en mi CV, me cabreé. La verdad es que no me costó demasiado encontrar mi primer trabajo, el sector se encontraba en la parte alta de un ciclo, aunque ni por asomo se acercaba a la locura que estamos viviendo ahora.&lt;/p&gt;

&lt;!--break--&gt;

&lt;p&gt;Total, que una vez inicié mi andadura en una típica cárnica española, consideré que mi inteligencia me haría crecer profesionalmente sin que yo hiciera gran cosa en mi tiempo libre, aparte de trabajar de la mejor forma que podía cuando estaba en la oficina. Ocurrió que la forma de trabajar en ese primer equipo no era demasiado colaborativa y no favorecía demasiado el aprendizaje. Además, como ya comenté en &lt;a href=&quot;/2015/08/10-years/&quot;&gt;mi post de 10 años de profesional&lt;/a&gt; no elegí demasiado sabiamente las tecnologías más apropiadas para un primer puesto de trabajo. Por último, el ambiente, lleno de continuas quejas sobre lo mal que estaba nuestro sector (“hay que dejar la informática”), hizo que me desmotivara y estancara.&lt;/p&gt;

&lt;p&gt;Mi segunda empresa, la consultora más grande de España, no hizo sino hundirme más en el pozo. Aquel proyecto era tóxico, con docenas de personas sin hacer nada, cosa que justificaban debido a las no subidas de sueldo. Al menos en este caso reaccioné a tiempo.&lt;/p&gt;

&lt;p&gt;En mi tercera empresa estuve más de cinco años, y la verdad es que disfruté de casi todo mi tiempo allí. Pero se dió un pequeño problema, trabajaba prácticamente solo como desarrollador en Madrid. No había discusiones sobre decisiones técnicas, y de revisiones de código o pair programming ni hablemos. Como nunca tuve a nadie diciéndome si hacía o no bien las cosas, aunque yo intentaba hacerlas bien, como nunca me formaba ni leía, pues las hacía más mal que bien, aunque, todo sea dicho, ninguno de los proyectos en los que trabajé fue un fracaso, ya que siempre intenté trabajar duro. Así que quizás no fuera un mal trabajador, pero sí era un mal programador, de ahí el título de este post. Hoy seguramente se me caería la cara de vergüenza si viera el código que entregué durante esos años.&lt;/p&gt;

&lt;p&gt;Hace unos cuatro años todo cambió, la historia no es sencilla de contar en un simple post, pero varios factores contribuyeron a que me diera cuenta de lo mal que estaba llevando mi carrera profesional. Así que me puse las pilas: leí muchos libros, estudié muchos cursos, comencé a seguir muchísimas webs (para &lt;a href=&quot;/2015/10/estar-al-dia/&quot;&gt;estar al día&lt;/a&gt;), &lt;a href=&quot;/2016/12/aprender-ingles/&quot;&gt;estudié inglés&lt;/a&gt;…en fin, todo lo que debería haber hecho y no hice al principio de mi carrera. Quizás malgasté siete u ocho años en total, y aunque no me queje del momento en que me encuentro ahora, quien sabe cómo de diferente habría sido todo si no hubiera metido tanto la pata al principio.&lt;/p&gt;

&lt;p&gt;Si escribo este post es únicamente para que un potencial lector que se esté iniciando en este mundo tan apasionante no cometa los mismos errores que cometí yo y se convierta en un mal programador sin posibilidad de vuelta atrás. Así que, por favor, nunca nunca:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Dejéis de aprender: leed libros (&lt;a href=&quot;https://jasonroell.com/2015/03/16/12-most-infuential-books-every-software-engineer-needs-to-read/&quot;&gt;aquí tenéis una buena lista para empezar&lt;/a&gt;), suscribiros a newsletters como la de &lt;a href=&quot;https://dzone.com/&quot;&gt;DZone&lt;/a&gt;, seguid a las personas adecuadadas en Twitter…&lt;/li&gt;
  &lt;li&gt;Trabajéis sin un buen mentor a vuestro lado: donde digo mentor me vale “buen programador”. Es necesario que alguien critique vuestro trabajo, es la mejor forma de aprender. Y por supuesto, nunca os toméis las críticas como algo personal&lt;/li&gt;
  &lt;li&gt;Dejéis de asistir a eventos técnicos: se aprende muchísimo, y lo mejor de todo, se conoce a gente muy interesante&lt;/li&gt;
  &lt;li&gt;Dejéis de disfrutar de vuestro trabajo: si no disfrutáis el día a día, buscad otro sitio. Nos podemos permitir ese lujo, y lo peor que nos puede ocurrir es caer en la desmotivación&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La lista podría continuar con otras cosas: escribir un blog, colaborar en proyectos Open Source…pero nada de eso me parece tan importante como los cuatro puntos que he reflejado.&lt;/p&gt;

&lt;p&gt;Y como último consejo, ¡sed humildes! Nadie está en posesión de la verdad absoluta, fundamentalmente porque tal verdad no existe, y siempre habrá ahí fuera gente que sepa mucho más que vosotros. De hecho, en este post no estoy diciendo que yo ahora sea un buen programador para nada. Es fácil decir cuando algo no es bueno, pero no es tan fácil decir cuando lo es.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Mis propósitos para 2017</title>
   <link href="http://www.raulavila.com/2017/01/propositos-2017/"/>
   <updated>2017-01-01T00:00:00+00:00</updated>
   <id>http://www.raulavila.com/2017/01/propositos-2017</id>
   <content type="html">&lt;p&gt;¡Feliz 2017! Es la primera vez que escribo un post en un primero de Enero, cosa que sólo fue posible hacer en 2016 ya que este blog nació a finales de Enero de 2015 :) El motivo de encontrarme en pijama tecleando unas palabras es que, animado por la &lt;a href=&quot;http://us2.campaign-archive2.com/?u=374c664073e1a1fa3deca53b4&amp;amp;id=f0e4a3e3ec&amp;amp;e=b93d18ec09&quot;&gt;Bonilista&lt;/a&gt; y otros blogs de tuiteros que sigo, he decidido plasmar en un post mis objetivos para este año que empieza, y que será bastante desafiante para mí, sobre todo a nivel profesional.&lt;/p&gt;

&lt;!--break--&gt;

&lt;p&gt;Así que allá vamos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hacer un buen trabajo en mi nuevo rol en &lt;a href=&quot;http://pivotal.io/&quot;&gt;Pivotal&lt;/a&gt;: inicié mi andadura en Pivotal el 1 de Febrero de 2016, y once meses después (el 3 de Enero, con el nuevo año) me uniré a un proyecto en el rol de anchor (algo así como “Team Leader”, &lt;a href=&quot;https://medium.com/built-to-adapt/the-pivotal-glossary-93b8be9de916&quot;&gt;en este artículo&lt;/a&gt; tenéis una descripción de todos los roles que existen en mi empresa). No es un ascenso en realidad, tan solo uno de los roles que se pueden desempeñar si eres Senior. Esto significa que existe la posibilidad de ser anchor en un proyecto y no serlo en el siguiente, a diferencia de la típica escalera corporativa. Pero bien es cierto que el cambio en mis tareas va a ser importante durante unos meses, sé que al principio será algo complicado, pero me encuentro bastante motivado, y me va a servir para aprender un montón.&lt;/li&gt;
  &lt;li&gt;Mejorar mi vocabulario en inglés: en este momento, el vocabulario es mi punto débil en inglés con diferencia. He reflexionado un poco y creo que mi problema es la falta de método para interiorizar nuevas palabras. Cada día escucho, leo o incluso tengo que utilizar alguna palabra nueva (con la ayuda de WordReference en este caso), pero no las registro en ningún lado, y si necesito usarlas en un período de tiempo no las recuerdo. Existe un sistema conocido como &lt;a href=&quot;http://ankisrs.net/&quot;&gt;Anki Cards&lt;/a&gt;, son tarjetas con dos caras que se pueden utilizar para repasar este tipo de cosas (no entraré en detalles aquí). Lo empecé a utilizar hace un año, pero abandoné. Pienso retomarlo de nuevo, y la medida de mi éxito en este punto será poder “jugar” a Anki en Diciembre con un porcentaje alto de aciertos. Veremos.&lt;/li&gt;
  &lt;li&gt;Llevar un registro de los libros que termine: creo que es muy útil registrar &lt;a href=&quot;http://evernote.com&quot;&gt;en algún lado&lt;/a&gt; los libros leídos, para poder mirar atrás y recapacitar sobre lo aprendido. Antiguamente con los libros en papel bastaba con ir a tu biblioteca particular, pero ahora, con el Kindle, &lt;a href=&quot;https://www.safaribooksonline.com&quot;&gt;Safari Books&lt;/a&gt;, audiolibros…es más complicado. Leo menos de lo que querría, pero me gustaría tener una métrica real para poder valorarlo a final de año. La verdad es que este objetivo debería ser fácil :).&lt;/li&gt;
  &lt;li&gt;Rodar y mejorar mis dotes de public speaking: el año pasado dí &lt;a href=&quot;https://skillsmatter.com/skillscasts/8851-lscc-meetup&quot;&gt;mi primera charla en inglés&lt;/a&gt;, un par de veces además. Estoy bastante contento con su contenido, y creo que la mejoraré y repetiré en algún evento durante 2017. Me gustaría, además, poder presentarla en español, así que la propondré en &lt;a href=&quot;/2016/11/codemotion-2016/&quot;&gt;Codemotion&lt;/a&gt;, donde creo que encaja bien (llevo varios años intentando hablar en esta gran conferencia), y quizás algún otro sarao. También tengo algunas ideas para nuevas charlas, por lo que como parte de este objetivo tengo desarrollar una nueva ponencia.&lt;/li&gt;
  &lt;li&gt;Ir al gimnasio al menos tres veces por semana: este objetivo prácticamente lo tengo cumplido por defecto, en 2016 no hubo semana que bajara de dos días en el gimnasio. Pero sé que, debido al trabajo, necesito no perder de vista esto, así que intentaré llevar un control algo más exhaustivo.&lt;/li&gt;
  &lt;li&gt;Conocer a más gente de la comunidad, tanto en Londres como en España: cada vez tengo más conocidos en el mundillo, me muevo bastante por Londres, sobre todo en eventos de la &lt;a href=&quot;https://www.meetup.com/london-software-craftsmanship/&quot;&gt;LSCC&lt;/a&gt; y la &lt;a href=&quot;https://www.meetup.com/Londonjavacommunity&quot;&gt;LJC&lt;/a&gt;, así que de tanto ver las mismas caras acabas conociendo a mucha gente. En España lo tengo algo más complicado, Twitter es muy bueno en esto, y en 2016 el &lt;a href=&quot;/2016/11/codemotion-2016/&quot;&gt;Codemotion&lt;/a&gt; fue una gran oportunidad para conocer a figuras importantes de la escena española. En este año me gustaría consolidar alguna de las relaciones iniciadas, y comenzar otras.&lt;/li&gt;
  &lt;li&gt;Escribir al menos 15 posts en el blog: no es un objetivo demasiado ambicioso, pero quiero ser realista. Estoy muy orgulloso de todo el trabajo que he realizado aquí, y me gustaría mantener un ritmo razonable, sin quemarme.&lt;/li&gt;
  &lt;li&gt;Publicar al menos 5 posts en &lt;a href=&quot;https://dev.to/&quot;&gt;The Practical Dev&lt;/a&gt;: como ya conté hace poco, decidí comenzar a escribir en inglés fuera de este blog, y la plataforma elegida fue &lt;a href=&quot;https://dev.to/&quot;&gt;The Practical Dev&lt;/a&gt;. En este año quiero incrementar mi presencia en esta web, sin ser demasiado ambicioso. En realidad, de momento me estoy dedicando a traducir artículos escritos en el blog, pero no descarto publicar algo más “exclusivo”.&lt;/li&gt;
  &lt;li&gt;Terminar al menos un curso online “end to end”: con esto quiero decir completando todas las prácticas, exámenes, o lo que sea. Veo muchos vídeos o tutoriales de forma habitual, pero con cursos completos no soy tan consistente. En 2016 conseguí completar el &lt;a href=&quot;https://www.coursera.org/learn/progfun1&quot;&gt;popular curso de Scala en Coursera &lt;/a&gt;, pero fracasé en completar la especialización, que era mi objetivo en realidad. El motivo fue que no ví un retorno de la inversión claro, dada la dificultad de las prácticas. Quizás este año finalice alguna de las otras partes de la especialización, o quizás me líe la manta a la cabeza con alguna otra cosa que considere más interesante.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Creo que lo dejaré aquí, sé que será casi imposible conseguir todo lo que pretendo, pero siempre hay que apuntar alto, ¿verdad? A finales de año repasaré cómo ha ido todo, y veré si tuvo sentido escribir esto.&lt;/p&gt;
</content>
 </entry>
 

</feed>
